

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Airline Dataset &mdash; RHIPE 0.65.3 documentation</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.65.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/theme_extras.js"></script>
    <link rel="top" title="RHIPE 0.65.3 documentation" href="index.html" />
    <link rel="next" title="Transforming Text Data" href="texttransfirm.html" />
    <link rel="prev" title="Introduction" href="introduction.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="index.html">
          <span>RHIPE 0.65.3 documentation</span></a></h1>
        <h2 class="heading"><span>Airline Dataset</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="introduction.html">Introduction</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="texttransfirm.html">Transforming Text Data</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="airline-dataset">
<h1>Airline Dataset<a class="headerlink" href="#airline-dataset" title="Permalink to this headline">¶</a></h1>
<p id="index-0">The Airline data set consists of flight arrival and departure details for all
commercial flights from 1987 to 2008. The approximately 120MM records (CSV format),  occupy
120GB space. The data set was used for the Visualization Poster Competition, JSM
2009. The winning entries can be found <a class="reference external" href="http://stat-computing.org/dataexpo/2009/">here</a> .
To quote the objectives</p>
<blockquote>
<div><p>&#8220;The aim of the data expo is to provide a graphical summary of important
features of the data set. This is intentionally vague in order to allow
different entries to focus on different aspects of the data, but here are a
few ideas to get you started:</p>
<ul class="simple">
<li>When is the best time of day/day of week/time of year to fly to minimise delays?</li>
<li>Do older planes suffer more delays?</li>
<li>How does the number of people flying between different locations change over time?</li>
<li>How well does weather predict plane delays?</li>
<li>Can you detect cascading failures as delays in one airport create delays in
others? Are there critical links in the system?&#8221;</li>
</ul>
</div></blockquote>
<p>In this chapter, I will demonstrate RHIPE code samples to create similar
graphics found in the winning entries <a class="reference internal" href="#sas">[SAS]</a> and <a class="reference internal" href="#flusa">[FLUSA]</a></p>
<table class="docutils citation" frame="void" id="sas" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[SAS]</a></td><td>Congestion in the Sky: Vizualising Domestic Airline Traffic with SAS, Rick Wicklin and Robert Allison, <em>SAS Institute</em>. <a class="reference external" href="http://stat-computing.org/dataexpo/2009/posters/wicklin-allison.pdf">http://stat-computing.org/dataexpo/2009/posters/wicklin-allison.pdf</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="flusa" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[FLUSA]</a></td><td>Delayed, Cancelled, On-Time, Boarding ... Flying in the USA, Heike  Hofmann, Di Cook, Chris Kielion, Barret Schloerke, Jon Hobbs, Adam Loy,Lawrence Mosley, David Rockoff, Yuanyuan Sun, Danielle Wrolstad and Tengfei. Yin, <em>Iowa State University</em>, <a class="reference external" href="http://stat-computing.org/dataexpo/2009/posters/hofmann-cook.pdf">http://stat-computing.org/dataexpo/2009/posters/hofmann-cook.pdf</a></td></tr>
</tbody>
</table>
<div class="section" id="copying-the-data-to-the-hdfs-or-a-distributed-downloader">
<h2>Copying the Data to the HDFS (or a <em>Distributed Downloader</em>!)<a class="headerlink" href="#copying-the-data-to-the-hdfs-or-a-distributed-downloader" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-1"></span><p id="downloading-airline-data"><span id="index-2"></span>The Airline data can be found <a class="reference external" href="http://stat-computing.org/dataexpo/2009/the-data.html">at this site</a> .
In this example, we download the data sets for the individual years and save
them on the HDFS with the following code (with limited error checks)</p>
<div class="highlight-r"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></div></td><td class="code"><div class="highlight"><pre>library<span class="p">(</span>Rhipe<span class="p">)</span>
rhinit<span class="p">(</span><span class="kc">TRUE</span><span class="p">,</span><span class="kc">TRUE</span><span class="p">)</span>
map <span class="o">&lt;-</span> expression<span class="p">({</span>
  msys <span class="o">&lt;-</span> <span class="kr">function</span><span class="p">(</span>on<span class="p">){</span>
    system<span class="p">(</span>sprintf<span class="p">(</span><span class="s">&quot;wget  %s --directory-prefix ./tmp 2&gt; ./errors&quot;</span><span class="p">,</span>on<span class="p">))</span>
    <span class="kr">if</span><span class="p">(</span>length<span class="p">(</span>grep<span class="p">(</span><span class="s">&quot;(failed)|(unable)&quot;</span><span class="p">,</span>readLines<span class="p">(</span><span class="s">&quot;./errors&quot;</span><span class="p">)))</span><span class="o">&gt;</span><span class="m">0</span><span class="p">){</span>
      stop<span class="p">(</span>paste<span class="p">(</span>readLines<span class="p">(</span><span class="s">&quot;./errors&quot;</span><span class="p">),</span>collapse<span class="o">=</span><span class="s">&quot;\n&quot;</span><span class="p">))</span>
    <span class="p">}}</span>

  lapply<span class="p">(</span>map.values<span class="p">,</span><span class="kr">function</span><span class="p">(</span>x<span class="p">){</span>
    x<span class="o">=</span><span class="m">1986</span><span class="o">+</span>x
    on <span class="o">&lt;-</span> sprintf<span class="p">(</span><span class="s">&quot;http://stat-computing.org/dataexpo/2009/%s.csv.bz2&quot;</span><span class="p">,</span>x<span class="p">)</span>
    fn <span class="o">&lt;-</span> sprintf<span class="p">(</span><span class="s">&quot;./tmp/%s.csv.bz2&quot;</span><span class="p">,</span>x<span class="p">)</span>
    rhstatus<span class="p">(</span>sprintf<span class="p">(</span><span class="s">&quot;Downloading %s&quot;</span><span class="p">,</span> on<span class="p">))</span>
    msys<span class="p">(</span>on<span class="p">)</span>
    rhstatus<span class="p">(</span>sprintf<span class="p">(</span><span class="s">&quot;Downloaded %s&quot;</span><span class="p">,</span> on<span class="p">))</span>
    system<span class="p">(</span>sprintf<span class="p">(</span><span class="s">&#39;bunzip2 %s&#39;</span><span class="p">,</span>fn<span class="p">))</span>
    rhstatus<span class="p">(</span>sprintf<span class="p">(</span><span class="s">&quot;Unzipped %s&quot;</span><span class="p">,</span> on<span class="p">))</span>
    rhcounter<span class="p">(</span><span class="s">&quot;FILES&quot;</span><span class="p">,</span>x<span class="p">,</span><span class="m">1</span><span class="p">)</span>
    rhcounter<span class="p">(</span><span class="s">&quot;FILES&quot;</span><span class="p">,</span><span class="s">&quot;_ALL_&quot;</span><span class="p">,</span><span class="m">1</span><span class="p">)</span>
  <span class="p">})</span>
<span class="p">})</span>
z <span class="o">&lt;-</span> rhmr<span class="p">(</span>map<span class="o">=</span>map<span class="p">,</span>ofolder<span class="o">=</span><span class="s">&quot;/airline/data&quot;</span><span class="p">,</span>inout<span class="o">=</span>c<span class="p">(</span><span class="s">&quot;lapply&quot;</span><span class="p">),</span> N<span class="o">=</span>length<span class="p">(</span><span class="m">1987</span>:<span class="m">2008</span><span class="p">),</span>
          mapred<span class="o">=</span>list<span class="p">(</span>mapred.reduce.tasks<span class="o">=</span><span class="m">0</span><span class="p">,</span>mapred.task.timeout<span class="o">=</span><span class="m">0</span><span class="p">),</span>copyFiles<span class="o">=</span><span class="kc">TRUE</span><span class="p">)</span>
j <span class="o">&lt;-</span> rhex<span class="p">(</span>z<span class="p">,</span>async<span class="o">=</span><span class="kc">TRUE</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>A lot is demonstrated in this code. RHIPE is loaded via the call in line 1. A
MapReduce job takes a set of input keys, in this case the numbers 1987
to 2008. It also takes a corresponding set of values. The parameter <tt class="docutils literal"><span class="pre">inout</span></tt> in
line 22 tells RHIPE how to convert the input the data to key, value pairs. If
the input file is a binary file but <tt class="docutils literal"><span class="pre">inout</span></tt> specifies <em>text</em> as the input,
RHIPE will not throw an error but provide very unexpected key,value
pairs. <tt class="docutils literal"><span class="pre">inout</span></tt> in this case is <em>lapply</em>, which treats the numbers 1 to <tt class="docutils literal"><span class="pre">N</span></tt>
(in line 22) as both keys and values.</p>
<p>These <em>N</em> key,value pairs are partitioned into <em>splits</em>. How they are
partitioned depends on the value of <tt class="docutils literal"><span class="pre">inout[1]</span></tt>. For text files
(<tt class="docutils literal"><span class="pre">inout[1]='text'</span></tt>), the data is split into roughly equi-length blocks of
e.g. 128MB each. A CSV text file will have approximately equal number of lines
per block (not necessarily). RHIPE will launch R across all the compute
nodes. Each node is responsible for processing a the key,value pairs in its
assigned splits.</p>
<p>This processing is performed in the <tt class="docutils literal"><span class="pre">map</span></tt> argument to <tt class="docutils literal"><span class="pre">rhmr</span></tt>. The <tt class="docutils literal"><span class="pre">map</span></tt>
argument is an R expression. Hadoop will read key,value pairs, send them to
RHIPE which in turn buffers them by storing them in a R list: <em>map.values</em> and
<em>map.keys</em> respectively. Once the buffer is full, RHIPE calls the <tt class="docutils literal"><span class="pre">map</span></tt>
expression. The default length of <em>map.values</em> (and <em>map.keys</em>) is 10,000 <a class="footnote-reference" href="#f1" id="id3">[1]</a>.</p>
<p>In our example, N is 22. The variables <em>map.values</em> and <em>map.keys</em> will be lists
of numbers 1 to 22 and strings &#8220;1&#8221; to &#8220;22&#8221; respectively. The entries need not be
in the order 1 to 22.</p>
<p><tt class="docutils literal"><span class="pre">rhmr</span></tt> is a call that packages the MapReduce job which is sent to Hadoop. It
takes an input folder which can contain multiple files and subfolders. All the
files will be given as input. If a particular file cannot be understood by the
input format (e.g. a text file given to <tt class="docutils literal"><span class="pre">inout[1]='sequence'</span></tt>), RHIPE will throw an error.</p>
<p>The expression downloads the CSV file, unzips its, and stores in the folder
<em>tmp</em> located in the current directory. No copying is performed. The current
directory is a temporary directory on the local filesystem of the compute node,
<strong>not</strong> on the HDFS. Upon successful completion of the split, the files
stored in <em>tmp</em> (of the current directory) will be copied to the output folder
specified by <tt class="docutils literal"><span class="pre">ofolder</span></tt> in the call to <tt class="docutils literal"><span class="pre">rhmr</span></tt>. Files are copied <strong>only if</strong>
<tt class="docutils literal"><span class="pre">copyFiles</span></tt> is set to TRUE (in line 23).</p>
<p>Once a file has been downloaded, we inform Hadoop of our change in status, via
<tt class="docutils literal"><span class="pre">rhastatus</span></tt>. The figure <a class="reference internal" href="#example-of-rhstatus"><em>Example of rhstatus</em></a> displays the various status of each
of the 22 splits (also called Tasks)</p>
<div class="figure align-center" id="example-of-rhstatus">
<img alt="_images/rhstatus1.pdf" src="_images/rhstatus1.pdf" />
<p class="caption">Example of <tt class="docutils literal"><span class="pre">rhstatus</span></tt></p>
</div>
<p>Once a file has been downloaded, we increment a <strong>distributed count</strong>. Counts
belong to families, a single family contains many counters. The counter for
group <em>G</em> and name <em>N</em> is incremented via a call to <tt class="docutils literal"><span class="pre">rhcounter</span></tt>. We increment
a counter for each of the 22 files. Since each file is downloaded once, this is
essentially a flag to indicate successful download. A count of files downloaded
is tracked in <em>Files/_ALL_</em> .</p>
<p>The operation of Hadoop is affected by many options, some of which can be found
in <em class="xref std std-ref">Options For RHIPE</em>. Hadoop will terminate splits (Tasks) after 10
minutes if they do not invoke <tt class="docutils literal"><span class="pre">rhstatus</span></tt> or return. Since each download takes
approximately 30 minutes (the minimum is 4 minutes, the maximum is 42 minutes,
the mean is 30 minutes), Hadoop will kill the tasks. We tell Hadoop to not
kill long running tasks by setting <em>mapred.task.timeout</em> to 0.  We do not to
need to reduce our results so we set <em>mapred.reduce.tasks</em> to 0. Output from the
map is written directly to the output folder on the HDFS. We do not have any
output. These options are passed in the <tt class="docutils literal"><span class="pre">mapred</span></tt> argument.</p>
<p>The call to <tt class="docutils literal"><span class="pre">rhex</span></tt> launches the job across Hadoop. We use the <tt class="docutils literal"><span class="pre">async</span></tt>
argument to return control of the R console to the user. We can monitor the
status in two ways</p>
<ul class="simple" id="index-3">
<li>Print the return value of <tt class="docutils literal"><span class="pre">rhex</span></tt>. The name of the job can be changed by giving a value to <tt class="docutils literal"><span class="pre">jobname</span></tt> in the
call to <tt class="docutils literal"><span class="pre">rhmr</span></tt>. The same information can be found at the Hadoop job tracker.</li>
</ul>
<div class="highlight-r"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27</pre></div></td><td class="code"><div class="highlight"><pre><span class="o">&gt;</span> j
RHIPE Job Token Information
<span class="o">--------------------------</span>
URL: http:<span class="o">//</span>spica:<span class="m">50030</span><span class="o">/</span>jobdetails.jsp?jobid<span class="o">=</span>job_201007281701_0053
Name: <span class="m">2010</span><span class="o">-</span><span class="m">07</span><span class="o">-</span><span class="m">28</span> <span class="m">23</span>:<span class="m">33</span>:<span class="m">44</span>
ID: job_201007281701_0053
Submission Time: <span class="m">2010</span><span class="o">-</span><span class="m">07</span><span class="o">-</span><span class="m">28</span> <span class="m">23</span>:<span class="m">33</span>:<span class="m">45</span>
State: RUNNING
Duration<span class="p">(</span>sec<span class="p">)</span>: <span class="m">11.702</span>
Progess
       pct numtasks pending running complete failed
map      <span class="m">0</span>       <span class="m">22</span>       <span class="m">1</span>      <span class="m">21</span>        <span class="m">0</span>      <span class="m">0</span>
reduce   <span class="m">0</span>        <span class="m">0</span>       <span class="m">0</span>       <span class="m">0</span>        <span class="m">0</span>      <span class="m">0</span>

<span class="o">&gt;</span> j
RHIPE Job Token Information
<span class="o">--------------------------</span>
URL: http:<span class="o">//</span>spica:<span class="m">50030</span><span class="o">/</span>jobdetails.jsp?jobid<span class="o">=</span>job_201007281701_0053
Name: <span class="m">2010</span><span class="o">-</span><span class="m">07</span><span class="o">-</span><span class="m">28</span> <span class="m">23</span>:<span class="m">33</span>:<span class="m">44</span>
ID: job_201007281701_0053
Submission Time: <span class="m">2010</span><span class="o">-</span><span class="m">07</span><span class="o">-</span><span class="m">28</span> <span class="m">23</span>:<span class="m">33</span>:<span class="m">45</span>
State: RUNNING
Duration<span class="p">(</span>sec<span class="p">)</span>: <span class="m">56.417</span>
Progess
       pct numtasks pending running complete failed
map      <span class="m">1</span>       <span class="m">22</span>       <span class="m">0</span>      <span class="m">22</span>        <span class="m">0</span>      <span class="m">0</span>
reduce   <span class="m">0</span>        <span class="m">0</span>       <span class="m">0</span>       <span class="m">0</span>        <span class="m">0</span>      <span class="m">0</span>
</pre></div>
</td></tr></table></div>
<ul class="simple">
<li>By calling <tt class="docutils literal"><span class="pre">rhstatus</span></tt>, giving it the value returned from <tt class="docutils literal"><span class="pre">rhex</span></tt> or the job
ID (e.g. <em>job_201007281701_0053</em>).</li>
</ul>
<div class="highlight-r"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></div></td><td class="code"><div class="highlight"><pre><span class="o">&gt;</span> a <span class="o">&lt;-</span> rhstatus<span class="p">(</span>j<span class="p">)</span> <span class="c1">## or rhstatus(&quot;job_201007281701_0053&quot;)</span>
<span class="o">&gt;</span> a<span class="p">$</span>state
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="s">&quot;RUNNING&quot;</span>
<span class="o">&gt;</span> a<span class="p">$</span>duration
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">902.481</span>
<span class="o">&gt;</span> a<span class="p">$</span>counters
<span class="p">$</span>counters
<span class="p">$</span>counters<span class="p">$</span><span class="sb">`Job Counters `</span>
Launched map tasks
                <span class="m">22</span>

<span class="p">$</span>counters<span class="p">$</span>FileSystemCounters
   FILE_BYTES_READ HDFS_BYTES_WRITTEN
         <span class="m">127162942</span>          <span class="m">127162942</span>

<span class="p">$</span>counters<span class="p">$</span><span class="sb">`&quot;FILES&quot;`</span>
 <span class="m">1987.0</span> <span class="s">&quot;_ALL_&quot;</span>
      <span class="m">1</span>       <span class="m">1</span>

<span class="p">$</span>counters<span class="p">$</span><span class="sb">`Map-Reduce Framework`</span>
 Map input records    Spilled Records Map output records
                <span class="m">22</span>                  <span class="m">0</span>                  <span class="m">0</span>

<span class="p">$</span>counters<span class="p">$</span>job_time
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">902.481</span>
</pre></div>
</td></tr></table></div>
<p>This distributed download took 45 minutes to complete, 15 seconds more than the
longest running download (2007.csv.bz2). A sequential download would have taken
several hours.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It is important to note that the above code is mostly boiler plate. There is
almost no lines to handle distribution across a cluster or task restart in case of
transient node failure. The user of RHIPE need only consider how to frame her
argument in the concepts of MapReduce.</p>
</div>
</div>
<div class="section" id="converting-to-r-objects">
<h2>Converting to R Objects<a class="headerlink" href="#converting-to-r-objects" title="Permalink to this headline">¶</a></h2>
<p>The data needs to be converted to R objects. Since we will be doing repeated
analyses on the data, it is better to spend time converting them to R objects
making subsequent computations faster, rather than tokenizing strings and
converting to R objects for every analysis.</p>
<p>A sample of the text file</p>
<div class="highlight-r"><div class="highlight"><pre><span class="m">1987</span><span class="p">,</span><span class="m">10</span><span class="p">,</span><span class="m">23</span><span class="p">,</span><span class="m">5</span><span class="p">,</span><span class="m">1841</span><span class="p">,</span><span class="m">1750</span><span class="p">,</span><span class="m">2105</span><span class="p">,</span><span class="m">2005</span><span class="p">,</span>PS<span class="p">,</span><span class="m">1905</span><span class="p">,</span><span class="kc">NA</span><span class="p">,</span><span class="m">144</span><span class="p">,</span><span class="m">135</span><span class="p">,</span><span class="kc">NA</span><span class="p">,</span><span class="m">60</span><span class="p">,</span><span class="m">51</span><span class="p">,</span>LAX<span class="p">,</span>SEA<span class="p">,</span><span class="m">954</span><span class="p">,</span><span class="kc">NA</span><span class="p">,</span><span class="kc">NA</span><span class="p">,</span><span class="m">0</span><span class="p">,</span><span class="kc">NA</span><span class="p">,</span><span class="m">0</span><span class="p">,</span><span class="m">...</span>
<span class="m">1987</span><span class="p">,</span><span class="m">10</span><span class="p">,</span><span class="m">24</span><span class="p">,</span><span class="m">6</span><span class="p">,</span><span class="m">1752</span><span class="p">,</span><span class="m">1750</span><span class="p">,</span><span class="m">2010</span><span class="p">,</span><span class="m">2005</span><span class="p">,</span>PS<span class="p">,</span><span class="m">1905</span><span class="p">,</span><span class="kc">NA</span><span class="p">,</span><span class="m">138</span><span class="p">,</span><span class="m">135</span><span class="p">,</span><span class="kc">NA</span><span class="p">,</span><span class="m">5</span><span class="p">,</span><span class="m">2</span><span class="p">,</span>LAX<span class="p">,</span>SEA<span class="p">,</span><span class="m">954</span><span class="p">,</span><span class="kc">NA</span><span class="p">,</span><span class="kc">NA</span><span class="p">,</span><span class="m">0</span><span class="p">,</span><span class="kc">NA</span><span class="p">,</span><span class="m">0</span><span class="p">,</span><span class="m">...</span>
<span class="m">...</span>
<span class="m">...</span>
</pre></div>
</div>
<p>The meaning of the columns can be found <a class="reference external" href="http://stat-computing.org/dataexpo/2009/the-data.html">here</a> .
Rather than store the entire 120MM rows as one big data frame, it is efficient
to store it as rectangular blocks of <em>R</em> rows and <em>M</em> columns. We will not store
all the above columns only the following:</p>
<ul class="simple">
<li>Dates: day of week, date, month and year (1,2,3, and 4)</li>
<li>Arrival and departure times: actual and scheduled (5,6,7 and 8)</li>
<li>Flight time: actual and scheduled (12 and 13)</li>
<li>Origin and Destination: airport code, latitude and longitude (17 and 18)</li>
<li>Distance (19)</li>
<li>Carrier Name (9)</li>
</ul>
<p>Since latitude and longitude are not present in the data sets, we will compute
them later as required. Carrier names are located in a different R data set
which will be used to do perform carrier code to carrier name translation.</p>
<p>We will store the data set as blocks of 5000 <img class="math" src="_images/math/bac4dbe1c696d11e8dc43dd7f613199b2120daa1.png" alt="\times"/> 5 rows and columns. These will
be the values. Every value must be mapped to a key. In this example, the keys
(indices) to these blocks will not have any meaning but will be unique. The key
is the first scheduled departure time.</p>
<p id="index-4">The format of the data is a <em>Sequence File</em>, which can store binary
representations of R objects.</p>
<div class="highlight-r" id="index-5"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40</pre></div></td><td class="code"><div class="highlight"><pre>setup <span class="o">&lt;-</span> expression<span class="p">({</span>
  convertHHMM <span class="o">&lt;-</span> <span class="kr">function</span><span class="p">(</span>s<span class="p">){</span>
    t<span class="p">(</span>sapply<span class="p">(</span>s<span class="p">,</span><span class="kr">function</span><span class="p">(</span>r<span class="p">){</span>
      l<span class="o">=</span>nchar<span class="p">(</span>r<span class="p">)</span>
      <span class="kr">if</span><span class="p">(</span>l<span class="o">==</span><span class="m">4</span><span class="p">)</span> c<span class="p">(</span>substr<span class="p">(</span>r<span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">),</span>substr<span class="p">(</span>r<span class="p">,</span><span class="m">3</span><span class="p">,</span><span class="m">4</span><span class="p">))</span>
      <span class="kr">else</span> <span class="kr">if</span><span class="p">(</span>l<span class="o">==</span><span class="m">3</span><span class="p">)</span> c<span class="p">(</span>substr<span class="p">(</span>r<span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">),</span>substr<span class="p">(</span>r<span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">3</span><span class="p">))</span>
      <span class="kr">else</span> c<span class="p">(</span><span class="s">&#39;0&#39;</span><span class="p">,</span><span class="s">&#39;0&#39;</span><span class="p">)</span>
    <span class="p">})</span>
  <span class="p">)}</span>
<span class="p">})</span>
map <span class="o">&lt;-</span> expression<span class="p">({</span>
  y <span class="o">&lt;-</span> do.call<span class="p">(</span><span class="s">&quot;rbind&quot;</span><span class="p">,</span>lapply<span class="p">(</span>map.values<span class="p">,</span><span class="kr">function</span><span class="p">(</span>r<span class="p">){</span>
    <span class="kr">if</span><span class="p">(</span>substr<span class="p">(</span>r<span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">4</span><span class="p">)</span><span class="o">!=</span><span class="s">&#39;Year&#39;</span><span class="p">)</span> strsplit<span class="p">(</span>r<span class="p">,</span><span class="s">&quot;,&quot;</span><span class="p">)[[</span><span class="m">1</span><span class="p">]]</span>
  <span class="p">}))</span>
  mu <span class="o">&lt;-</span> rep<span class="p">(</span><span class="m">1</span><span class="p">,</span>nrow<span class="p">(</span>y<span class="p">));</span>yr <span class="o">&lt;-</span> y<span class="p">[,</span><span class="m">1</span><span class="p">];</span> mn<span class="o">=</span>y<span class="p">[,</span><span class="m">2</span><span class="p">];</span>dy<span class="o">=</span>y<span class="p">[,</span><span class="m">3</span><span class="p">]</span>
  hr <span class="o">&lt;-</span> convertHHMM<span class="p">(</span>y<span class="p">[,</span><span class="m">5</span><span class="p">])</span>
  depart <span class="o">&lt;-</span> ISOdatetime<span class="p">(</span>year<span class="o">=</span>yr<span class="p">,</span>month<span class="o">=</span>mn<span class="p">,</span>day<span class="o">=</span>dy<span class="p">,</span>hour<span class="o">=</span>hr<span class="p">[,</span><span class="m">1</span><span class="p">],</span>min<span class="o">=</span>hr<span class="p">[,</span><span class="m">2</span><span class="p">],</span>sec<span class="o">=</span>mu<span class="p">)</span>
  hr <span class="o">&lt;-</span> convertHHMM<span class="p">(</span>y<span class="p">[,</span><span class="m">6</span><span class="p">])</span>
  sdepart <span class="o">&lt;-</span> ISOdatetime<span class="p">(</span>year<span class="o">=</span>yr<span class="p">,</span>month<span class="o">=</span>mn<span class="p">,</span>day<span class="o">=</span>dy<span class="p">,</span>hour<span class="o">=</span>hr<span class="p">[,</span><span class="m">1</span><span class="p">],</span>min<span class="o">=</span>hr<span class="p">[,</span><span class="m">2</span><span class="p">],</span>sec<span class="o">=</span>mu<span class="p">)</span>
  hr <span class="o">&lt;-</span> convertHHMM<span class="p">(</span>y<span class="p">[,</span><span class="m">7</span><span class="p">])</span>
  arrive <span class="o">&lt;-</span> ISOdatetime<span class="p">(</span>year<span class="o">=</span>yr<span class="p">,</span>month<span class="o">=</span>mn<span class="p">,</span>day<span class="o">=</span>dy<span class="p">,</span>hour<span class="o">=</span>hr<span class="p">[,</span><span class="m">1</span><span class="p">],</span>min<span class="o">=</span>hr<span class="p">[,</span><span class="m">2</span><span class="p">],</span>sec<span class="o">=</span>mu<span class="p">)</span>
  hr <span class="o">&lt;-</span> convertHHMM<span class="p">(</span>y<span class="p">[,</span><span class="m">8</span><span class="p">])</span>
  sarrive <span class="o">&lt;-</span> ISOdatetime<span class="p">(</span>year<span class="o">=</span>yr<span class="p">,</span>month<span class="o">=</span>mn<span class="p">,</span>day<span class="o">=</span>dy<span class="p">,</span>hour<span class="o">=</span>hr<span class="p">[,</span><span class="m">1</span><span class="p">],</span>min<span class="o">=</span>hr<span class="p">[,</span><span class="m">2</span><span class="p">],</span>sec<span class="o">=</span>mu<span class="p">)</span>
  d <span class="o">&lt;-</span> data.frame<span class="p">(</span>depart<span class="o">=</span> depart<span class="p">,</span>sdepart <span class="o">=</span> sdepart
                <span class="p">,</span>arrive <span class="o">=</span> arrive<span class="p">,</span>sarrive <span class="o">=</span>sarrive
                <span class="p">,</span>carrier <span class="o">=</span> y<span class="p">[,</span><span class="m">9</span><span class="p">],</span>origin <span class="o">=</span> y<span class="p">[,</span><span class="m">17</span><span class="p">]</span>
                <span class="p">,</span>dest<span class="o">=</span>y<span class="p">[,</span><span class="m">18</span><span class="p">],</span>dist <span class="o">=</span> y<span class="p">[,</span><span class="m">19</span><span class="p">],</span> year<span class="o">=</span>yr<span class="p">,</span> month<span class="o">-</span>mn<span class="p">,</span> day<span class="o">=</span>dy
                <span class="p">,</span>cancelled<span class="o">=</span>y<span class="p">[,</span><span class="m">22</span><span class="p">],</span> stringsAsFactors<span class="o">=</span><span class="kc">FALSE</span><span class="p">)</span>
  d <span class="o">&lt;-</span> d<span class="p">[</span>order<span class="p">(</span>d<span class="p">$</span>sdepart<span class="p">),]</span>
  rhcollect<span class="p">(</span>d<span class="p">[</span>c<span class="p">(</span><span class="m">1</span><span class="p">,</span>nrow<span class="p">(</span>d<span class="p">)),</span><span class="s">&quot;sdepart&quot;</span><span class="p">],</span>d<span class="p">)</span>
<span class="p">})</span>
reduce <span class="o">&lt;-</span> expression<span class="p">(</span>
    reduce <span class="o">=</span> <span class="p">{</span>
      lapply<span class="p">(</span>reduce.values<span class="p">,</span><span class="kr">function</span><span class="p">(</span>i<span class="p">)</span>
             rhcollect<span class="p">(</span>reduce.key<span class="p">,</span>i<span class="p">))}</span>
    <span class="p">)</span>
mapred <span class="o">&lt;-</span> list<span class="p">(</span>rhipe_map_buff_size<span class="o">=</span><span class="m">5000</span><span class="p">)</span>
z <span class="o">&lt;-</span> rhmr<span class="p">(</span>map<span class="o">=</span>map<span class="p">,</span>reduce<span class="o">=</span>reduce<span class="p">,</span>setup<span class="o">=</span>setup<span class="p">,</span>inout<span class="o">=</span>c<span class="p">(</span><span class="s">&quot;text&quot;</span><span class="p">,</span><span class="s">&quot;sequence&quot;</span><span class="p">)</span>
          <span class="p">,</span>ifolder<span class="o">=</span><span class="s">&quot;/airline/data/&quot;</span><span class="p">,</span>ofolder<span class="o">=</span><span class="s">&quot;/airline/blocks&quot;</span><span class="p">,</span>mapred<span class="o">=</span>mapred<span class="p">,</span>orderby<span class="o">=</span><span class="s">&quot;numeric&quot;</span><span class="p">)</span>
rhex<span class="p">(</span>z<span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>The <tt class="docutils literal"><span class="pre">setup</span></tt> expression is loaded into the R session <em>once</em> for every
split. Remember a split can consist of many <em>map.values</em> that need to be
processed. For text files as input, a split is 128MB or whatever your Hadoop
block size is. Lines 12-14, iterate over the lines and tokenizing them. The
first line in each downloaded file is the column year which must be ignored (see
line 13). The lines of text are aggregated using <tt class="docutils literal"><span class="pre">rbind</span></tt> and time related
columns converted to <em>datetime</em> objects. The data frame is sorted by scheduled
departure and saved to disk indexed by the range of scheduled departures in the
data frame. The size of the value (data frame) is important. RHIPE will can
write any sized object but cannot read key,values that are more than 256MB. A
data frame of 5000 rows and 8 columns fits very well into 256MB. This is passed
to Hadoop in line 37.</p>
<p>Running R across massive data can be illuminating. Without the calls to
<tt class="docutils literal"><span class="pre">ISOdatetime</span></tt>, it is <strong>much</strong> faster to complete.</p>
<span class="target" id="index-6"></span><div class="section" id="sorted-keys">
<span id="index-7"></span><h3>Sorted keys<a class="headerlink" href="#sorted-keys" title="Permalink to this headline">¶</a></h3>
<p>A reduce is not needed in this example. The text data is blocked
into data frames and written to disk. With 128MB block sizes and each block a
split, each split being mapped by one R session, there 96 files each
containing several data frames.  The reduce expression writes each incoming
intermediate value (a data frame) to disk. This is called an <em>identity reducer</em>
which can be used for</p>
<p>1. For map file indexing. The intermediate keys are sorted. In the identity
reduce, these keys are written to disk in sorted order. If the output format
(<tt class="docutils literal"><span class="pre">inout[2]</span></tt>) is <em>map</em>, the output can be used as an external memory hash
table. Given a key, RHIPE can use Hadoop to very quickly discover the location
of the key in the sorted (by key) output data and return the associated value. Thus even when no reduce logic
is required the user can provide the identity reduce to create a queryable Map
File from the map output.</p>
<p>2. Intermediate keys are sorted. But they can be sorted in different ways. RHIPE&#8217;s
default is <em>byte ordering</em> i.e the keys are serialized to bytes and sorted
byte wise. However, byte ordering is very different from semantic
ordering. Thus keys e.g. 10,-1,20 which might be byte ordered are certainly not
numerically ordered. RHIPE can numerically order keys so that in the reduce
expression the user is guaranteed to receive the keys in sorted numeric
order. In the above code, we request this feature in line 38. Numeric sorting
is as follows: keys A and B are ordered if <img class="math" src="_images/math/35c6befbae2835211a36a77a5e2708937cc6faac.png" alt="A&lt;B"/> and of unit length or
or <img class="math" src="_images/math/afbd1d55667fe2cdeb0368b574ec95aca68a02cd.png" alt="A[i]&lt;B[i], 1\le i \le min(length(A),length(B))"/> <a class="footnote-reference" href="#f2" id="id5">[2]</a>.
For keys <img class="math" src="_images/math/d19b3dc2c485c0a7de5303c104c886ddf2c420b0.png" alt="1,(2,1),(1,1),5,(1,3,4),(2,1),4,(4,9)"/> the ordering is <img class="math" src="_images/math/32170eb99c7aec671433bd469a9b0e4f3cacd109.png" alt="1,(1,1),(1,3,4),(2,1),(2,1),4,(4,9),5"/>
Using this ordering, all the values in a given file will be ordered by the
range of the scheduled departures.  Using this custom sorter can be slower than
the default byte ordering. Bear in mind, the keys in a <em>part</em> file will be ordered but keys in one <em>part</em> file need not be less than those in another <em>part</em> file.</p>
<p id="tuple-sorting">To achieve ordering of keys set <em>orderby</em> in the call to <tt class="docutils literal"><span class="pre">rhmr</span></tt> to one of
<em>bytes</em> (default), <em>integer</em>, <em>numeric</em> (for doubles) or <em>character</em>
(alphabetical sorting) in the <tt class="docutils literal"><span class="pre">mapred</span></tt> argument to <tt class="docutils literal"><span class="pre">rhmr</span></tt>. If the output
format is <em>sequence</em>, you also need to provide a reducer which can be an
identity reducer. Note, if your keys are discrete, it is best to use <em>integer</em> ordering. Values of NA can throw of ordering
and will send <em>all</em> key,values to one reducer causing a severe imbalance.</p>
<div class="highlight-r"><div class="highlight"><pre>reduce <span class="o">=</span> expression<span class="p">({</span>
  reduce<span class="o">=</span><span class="p">{</span> lapply<span class="p">(</span>reduce.values<span class="p">,</span><span class="kr">function</span><span class="p">(</span>r<span class="p">)</span> rhcollect<span class="p">(</span>reduce.key<span class="p">,</span>r<span class="p">))</span> <span class="p">}</span>
<span class="p">})</span>
</pre></div>
</div>
<p>3. To decrease the number of files. In this case decreasing the number of files is
hardly needed, but it can be useful if one has more thousands of splits.</p>
<p>In situations (1) and (3), the user does not have to provide the R reduce
expression and can leave this parameter empty. In situation (2), you need to
provide the above code. Also, (2) is incompatible with Map File outputs (i.e
<tt class="docutils literal"><span class="pre">inout[2]</span></tt> set to <em>map</em>). Case (2) is mostly useful for time series algorithms
in the reduce section e.g. keys of the form <img class="math" src="_images/math/0988099bddbda4ae8fba860ea5c32929cbbcb0fe.png" alt="(identifier,i)`"/> where
<em>identifier</em> is an object and <em>i</em> ranges from <em>1</em> to <img class="math" src="_images/math/2d2ea64202fb9e35ecff2bccd89529eed2362b12.png" alt="n_{identifier}"/>. For
each key, the value is sorted time series data. The reducer will receive the
values for the keys <img class="math" src="_images/math/0988099bddbda4ae8fba860ea5c32929cbbcb0fe.png" alt="(identifier,i)`"/> in the order of <em>i</em> for a given
<em>identifier</em>. This also assumes the user has partitioned the data on
<em>identifier</em> (see the <tt class="docutils literal"><span class="pre">part</span></tt> parameter of <tt class="docutils literal"><span class="pre">rhmr</span></tt>: for this to work, all the
keys  <img class="math" src="_images/math/0988099bddbda4ae8fba860ea5c32929cbbcb0fe.png" alt="(identifier,i)`"/> with the same <em>identifier</em> need to be sent to the
same reducer). For an example see <a class="reference internal" href="#streaming-data"><em>Streaming Data?</em></a>.</p>
<p>A sample data frame (last 4 columns removed):</p>
<div class="highlight-r"><div class="highlight"><pre>                 depart              sarrive      carrier origin dest dist cancelled
<span class="m">2880</span> <span class="m">1988</span><span class="o">-</span><span class="m">05</span><span class="o">-</span><span class="m">01</span> <span class="m">01</span>:<span class="m">02</span>:<span class="m">01</span> <span class="m">...</span> <span class="m">1988</span><span class="o">-</span><span class="m">05</span><span class="o">-</span><span class="m">01</span> <span class="m">01</span>:<span class="m">59</span>:<span class="m">01</span>      DL    SLC  SEA  <span class="m">689</span>         <span class="m">0</span>
<span class="m">3770</span> <span class="m">1988</span><span class="o">-</span><span class="m">05</span><span class="o">-</span><span class="m">01</span> <span class="m">01</span>:<span class="m">10</span>:<span class="m">01</span> <span class="m">...</span> <span class="m">1988</span><span class="o">-</span><span class="m">05</span><span class="o">-</span><span class="m">01</span> <span class="m">02</span>:<span class="m">13</span>:<span class="m">01</span>      DL    JAX  FLL  <span class="m">318</span>         <span class="m">0</span>
<span class="m">2137</span> <span class="m">1988</span><span class="o">-</span><span class="m">05</span><span class="o">-</span><span class="m">01</span> <span class="m">01</span>:<span class="m">10</span>:<span class="m">01</span> <span class="m">...</span> <span class="m">1988</span><span class="o">-</span><span class="m">05</span><span class="o">-</span><span class="m">01</span> <span class="m">01</span>:<span class="m">59</span>:<span class="m">01</span>      DL    TPA  PBI  <span class="m">174</span>         <span class="m">0</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="demonstration-of-using-hadoop-as-a-queryable-database">
<h2>Demonstration of using Hadoop as a Queryable Database<a class="headerlink" href="#demonstration-of-using-hadoop-as-a-queryable-database" title="Permalink to this headline">¶</a></h2>
<p id="index-8"><em>Sightly artificial</em>: store all Southwest Airlines information indexed by
year,month,and day. Each (year, month, day) triplet will have all flight entries
that left on that day. Using the above data set as the source, the Southwest
lines are selected and sent to the reducer with the (year, month,day) key. All
flights with the same (year, month) will belong to the same file. Given a (year,
month,day) triplet, we can use the Map File output format to access the
associated flight information in seconds rather than subsetting using MapReduce.</p>
<div class="highlight-r"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></div></td><td class="code"><div class="highlight"><pre>map <span class="o">&lt;-</span> expression<span class="p">({</span>
  h <span class="o">&lt;-</span> do.call<span class="p">(</span><span class="s">&quot;rbind&quot;</span><span class="p">,</span>map.values<span class="p">)</span>
  d <span class="o">&lt;-</span> h<span class="p">[</span>h<span class="p">$</span>carrier<span class="o">==</span><span class="s">&#39;WN&#39;</span><span class="p">,,</span>drop<span class="o">=</span><span class="kc">FALSE</span><span class="p">]</span>
  <span class="kr">if</span><span class="p">(</span>nrow<span class="p">(</span>d<span class="p">)</span><span class="o">&gt;</span><span class="m">0</span><span class="p">){</span>
    e <span class="o">&lt;-</span> split<span class="p">(</span>d<span class="p">,</span>list<span class="p">(</span>d<span class="p">$</span>year<span class="p">,</span>d<span class="p">$</span>month<span class="p">,</span>d<span class="p">$</span>mday<span class="p">))</span>
    lapply<span class="p">(</span>e<span class="p">,</span><span class="kr">function</span><span class="p">(</span>r<span class="p">){</span>
      k <span class="o">&lt;-</span> as.vector<span class="p">(</span>unlist<span class="p">(</span>r<span class="p">[</span><span class="m">1</span><span class="p">,</span>c<span class="p">(</span><span class="s">&quot;year&quot;</span><span class="p">,</span><span class="s">&quot;month&quot;</span><span class="p">,</span><span class="s">&quot;mday&quot;</span><span class="p">)]))</span>  <span class="c1">## remove attributes</span>
      rhcollect<span class="p">(</span>k<span class="p">,</span> r<span class="p">)</span>
    <span class="p">})</span>
  <span class="p">}</span>
<span class="p">})</span>
reduce <span class="o">&lt;-</span> expression<span class="p">(</span>
    pre <span class="o">=</span> <span class="p">{</span> collec <span class="o">&lt;-</span> <span class="kc">NULL</span> <span class="p">},</span>
    reduce <span class="o">=</span> <span class="p">{</span>
      collec <span class="o">&lt;-</span> rbind<span class="p">(</span>collec<span class="p">,</span> do.call<span class="p">(</span><span class="s">&quot;rbind&quot;</span><span class="p">,</span>reduce.values<span class="p">))</span>
      collec <span class="o">&lt;-</span> collec<span class="p">[</span>order<span class="p">(</span>collec<span class="p">$</span>depart<span class="p">),]</span>
    <span class="p">},</span>
    post <span class="o">=</span> <span class="p">{</span>
      rhcollect<span class="p">(</span>k<span class="p">,</span> collec<span class="p">)</span>
    <span class="p">}</span>
    <span class="p">)</span>
z <span class="o">&lt;-</span> rhmr<span class="p">(</span>map<span class="o">=</span>map<span class="p">,</span>reduce<span class="o">=</span>reduce<span class="p">,</span>combiner<span class="o">=</span><span class="kc">TRUE</span><span class="p">,</span>inout<span class="o">=</span>c<span class="p">(</span><span class="s">&quot;sequence&quot;</span><span class="p">,</span><span class="s">&quot;map&quot;</span><span class="p">)</span>
          <span class="p">,</span>ifolder<span class="o">=</span><span class="s">&quot;/airline/blocks/&quot;</span><span class="p">,</span>ofolder<span class="o">=</span><span class="s">&quot;/airline/southwest&quot;</span>
          <span class="p">,</span>mapred<span class="o">=</span>list<span class="p">(</span>rhipe_map_buff_size<span class="o">=</span><span class="m">10</span><span class="p">))</span>
rhex<span class="p">(</span>z<span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>Attributes are removed in line 8, for otherwise we have to retrieve a data frame
with a data frame with column names and row names instead of a more convenient
numeric vector.  The map expression combines the individual data frames. Each
data frame has 5000 rows, hence <em>rhipe_map_buff_size</em> is set to 10 for a
combined data frame of 50000 rows in line 32. This is crucial. The default value
for <em>rhipe_map_buff_size</em> is 10,000. Binding 10,000 data frames of 5000 rows
each creates a data frame of 50MN rows - too unwieldy to compute with in R (for
many types of operations). Data frames for Southwest Airlines (carried code=WN)
are created and emitted with the call to <tt class="docutils literal"><span class="pre">rhcollect</span></tt> in line 15. These are
combined in the reduce since data frames for the same (year, month,day) triplet
can be emitted from different map expressions. Since this is associative and
commutative we use a combiner. The output format (<tt class="docutils literal"><span class="pre">inout[[2]]</span></tt>) is <em>map</em>, so
we can access the flights for any triplet with a call to <tt class="docutils literal"><span class="pre">rhgetkey</span></tt> which
returns a list of key,value lists.</p>
<div class="highlight-r"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span class="o">&gt;</span> a <span class="o">&lt;-</span> rhgetkey<span class="p">(</span>list<span class="p">(</span>c<span class="p">(</span><span class="m">88</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">17</span><span class="p">)),</span><span class="s">&quot;/airline/southwest&quot;</span><span class="p">)</span>
<span class="o">&gt;</span> a<span class="p">[[</span><span class="m">1</span><span class="p">]][[</span><span class="m">1</span><span class="p">]]</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">93</span>  <span class="m">0</span>  <span class="m">1</span>
<span class="o">&gt;</span> head<span class="p">(</span>a<span class="p">[[</span><span class="m">1</span><span class="p">]][[</span><span class="m">2</span><span class="p">]][,</span><span class="m">1</span>:<span class="m">9</span><span class="p">])</span>
                    depart                 sarrive carrier origin dest dist cancelled
<span class="m">23648</span>  <span class="m">1993</span><span class="o">-</span><span class="m">01</span><span class="o">-</span><span class="m">01</span> <span class="m">00</span>:<span class="m">00</span>:<span class="m">01</span> <span class="m">...</span> <span class="m">1993</span><span class="o">-</span><span class="m">01</span><span class="o">-</span><span class="m">01</span> <span class="m">13</span>:<span class="m">35</span>:<span class="m">01</span>      WN    RNO  LAS  <span class="m">345</span>         <span class="m">1</span>
<span class="m">20714</span>  <span class="m">1993</span><span class="o">-</span><span class="m">01</span><span class="o">-</span><span class="m">01</span> <span class="m">07</span>:<span class="m">20</span>:<span class="m">01</span> <span class="m">...</span> <span class="m">1993</span><span class="o">-</span><span class="m">01</span><span class="o">-</span><span class="m">01</span> <span class="m">08</span>:<span class="m">40</span>:<span class="m">01</span>      WN    SFO  SAN  <span class="m">447</span>         <span class="m">0</span>
<span class="m">37642</span>  <span class="m">1993</span><span class="o">-</span><span class="m">01</span><span class="o">-</span><span class="m">01</span> <span class="m">07</span>:<span class="m">25</span>:<span class="m">01</span> <span class="m">...</span> <span class="m">1993</span><span class="o">-</span><span class="m">01</span><span class="o">-</span><span class="m">01</span> <span class="m">10</span>:<span class="m">15</span>:<span class="m">01</span>      WN    OAK  PHX  <span class="m">646</span>         <span class="m">0</span>
<span class="m">316110</span> <span class="m">1993</span><span class="o">-</span><span class="m">01</span><span class="o">-</span><span class="m">01</span> <span class="m">07</span>:<span class="m">30</span>:<span class="m">01</span> <span class="m">...</span> <span class="m">1993</span><span class="o">-</span><span class="m">01</span><span class="o">-</span><span class="m">01</span> <span class="m">08</span>:<span class="m">30</span>:<span class="m">01</span>      WN    OAK  BUR  <span class="m">325</span>         <span class="m">0</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="analyses">
<h2>Analyses<a class="headerlink" href="#analyses" title="Permalink to this headline">¶</a></h2>
<p>We compute some summaries and displays to understand the data.</p>
<div class="section" id="top-20-cities-by-total-volume-of-flights">
<h3>Top 20 cities by total volume of flights.<a class="headerlink" href="#top-20-cities-by-total-volume-of-flights" title="Permalink to this headline">¶</a></h3>
<p>What are the busiest cities by total flight traffic. JFK will feature, but what
are the others? For each airport code compute the number of inbound, outbound
and all flights.</p>
<div class="highlight-r" id="index-9"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></div></td><td class="code"><div class="highlight"><pre>map <span class="o">&lt;-</span> expression<span class="p">({</span>
  a <span class="o">&lt;-</span> do.call<span class="p">(</span><span class="s">&quot;rbind&quot;</span><span class="p">,</span>map.values<span class="p">)</span>
  inbound <span class="o">&lt;-</span> table<span class="p">(</span>a<span class="p">[,</span><span class="s">&#39;origin&#39;</span><span class="p">])</span>
  outbound <span class="o">&lt;-</span> table<span class="p">(</span>a<span class="p">[,</span><span class="s">&#39;dest&#39;</span><span class="p">])</span>
  total <span class="o">&lt;-</span> table<span class="p">(</span>unlist<span class="p">(</span>c<span class="p">(</span>a<span class="p">[,</span><span class="s">&#39;origin&#39;</span><span class="p">],</span>a<span class="p">[</span><span class="s">&#39;dest&#39;</span><span class="p">])))</span>
  <span class="kr">for</span><span class="p">(</span>n in names<span class="p">(</span>total<span class="p">)){</span>
    inb <span class="o">&lt;-</span> <span class="kr">if</span><span class="p">(</span>is.na<span class="p">(</span>inbound<span class="p">[</span>n<span class="p">]))</span> <span class="m">0</span> <span class="kr">else</span> inbound<span class="p">[</span>n<span class="p">]</span>
    ob <span class="o">&lt;-</span> <span class="kr">if</span><span class="p">(</span>is.na<span class="p">(</span>outbound<span class="p">[</span>n<span class="p">]))</span> <span class="m">0</span> <span class="kr">else</span> outbound<span class="p">[</span>n<span class="p">]</span>
    rhcollect<span class="p">(</span>n<span class="p">,</span> c<span class="p">(</span>inb<span class="p">,</span>ob<span class="p">,</span> total<span class="p">[</span>n<span class="p">]))</span>
  <span class="p">}</span>
<span class="p">})</span>
reduce <span class="o">&lt;-</span> expression<span class="p">(</span>
    pre<span class="o">=</span><span class="p">{</span>sums <span class="o">&lt;-</span> c<span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">0</span><span class="p">,</span><span class="m">0</span><span class="p">)},</span>
    reduce <span class="o">=</span> <span class="p">{</span>
      sums <span class="o">&lt;-</span> sums<span class="o">+</span>apply<span class="p">(</span>do.call<span class="p">(</span><span class="s">&quot;rbind&quot;</span><span class="p">,</span>reduce.values<span class="p">),</span><span class="m">2</span><span class="p">,</span>sum<span class="p">)</span>
    <span class="p">},</span>
    post <span class="o">=</span> <span class="p">{</span>
      rhcollect<span class="p">(</span>reduce.key<span class="p">,</span> sums<span class="p">)</span>
    <span class="p">}</span>
    <span class="p">)</span>
mapred<span class="p">$</span>rhipe_map_buff_size <span class="o">&lt;-</span> <span class="m">15</span>
z <span class="o">&lt;-</span> rhmr<span class="p">(</span>map<span class="o">=</span>map<span class="p">,</span>reduce<span class="o">=</span>reduce<span class="p">,</span>combiner<span class="o">=</span><span class="kc">TRUE</span><span class="p">,</span>inout<span class="o">=</span>c<span class="p">(</span><span class="s">&quot;sequence&quot;</span><span class="p">,</span><span class="s">&quot;sequence&quot;</span><span class="p">)</span>
          <span class="p">,</span>ifolder<span class="o">=</span><span class="s">&quot;/airline/blocks/&quot;</span><span class="p">,</span>ofolder<span class="o">=</span><span class="s">&quot;/airline/volume&quot;</span>
          <span class="p">,</span>mapred<span class="o">=</span>mapred<span class="p">)</span>
rhex<span class="p">(</span>z<span class="p">,</span>async<span class="o">=</span><span class="kc">TRUE</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>The code is straightforward. I increased the value of <em>rhipe_map_buff_size</em>
since we are doing summaries of columns. The figure <a class="reference internal" href="#time-to-complete-vs-rhipe-map-buff-size"><em>Log of time to complete vs log of rhipe_map_buff_size.</em></a> plots the time of completion vs the mean of three
trials for different values of <em>rhipe_map_buff_size</em>. The trials set
<em>rhipe_map_buff_size</em> to 5,10,15,20,25 and 125. All experiments (like the rest
in the manual) were performed on a 72 core cluster across 8 servers with RAM
varying from 16 to 64 GB.</p>
<div class="figure align-center" id="time-to-complete-vs-rhipe-map-buff-size">
<a class="reference internal image-reference" href="_images/rhipemapbuff.pdf"><img alt="_images/rhipemapbuff.pdf" src="_images/rhipemapbuff.pdf" /></a>
<p class="caption">Log of time to complete vs log of <em>rhipe_map_buff_size</em>.</p>
</div>
<p>Read the data into R and display them using the <tt class="docutils literal"><span class="pre">lattice</span></tt> library.</p>
<div class="highlight-r" id="index-10"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="highlight"><pre>counts <span class="o">&lt;-</span> rhread<span class="p">(</span><span class="s">&quot;/airline/volume&quot;</span><span class="p">)</span>
aircode <span class="o">&lt;-</span> unlist<span class="p">(</span>lapply<span class="p">(</span>counts<span class="p">,</span> <span class="s">&quot;[[&quot;</span><span class="p">,</span><span class="m">1</span><span class="p">))</span>
count <span class="o">&lt;-</span> do.call<span class="p">(</span><span class="s">&quot;rbind&quot;</span><span class="p">,</span>lapply<span class="p">(</span>counts<span class="p">,</span><span class="s">&quot;[[&quot;</span><span class="p">,</span><span class="m">2</span><span class="p">))</span>
results <span class="o">&lt;-</span> data.frame<span class="p">(</span>aircode<span class="o">=</span>aircode<span class="p">,</span>
                      inb<span class="o">=</span>count<span class="p">[,</span><span class="m">1</span><span class="p">],</span>oub<span class="o">=</span>count<span class="p">[,</span><span class="m">2</span><span class="p">],</span>all<span class="o">=</span>count<span class="p">[,</span><span class="m">3</span><span class="p">]</span>
                      <span class="p">,</span>stringsAsFactors<span class="o">=</span><span class="kc">FALSE</span><span class="p">)</span>
results <span class="o">&lt;-</span> results<span class="p">[</span>order<span class="p">(</span>results<span class="p">$</span>all<span class="p">,</span>decreasing<span class="o">=</span><span class="kc">TRUE</span><span class="p">),]</span>
results<span class="p">$</span>airport <span class="o">&lt;-</span> sapply<span class="p">(</span>results<span class="p">$</span>aircode<span class="p">,</span><span class="kr">function</span><span class="p">(</span>r<span class="p">){</span>
nam <span class="o">&lt;-</span> ap<span class="p">[</span>ap<span class="p">$</span>iata<span class="o">==</span>r<span class="p">,</span><span class="s">&#39;airport&#39;</span><span class="p">]</span>
<span class="kr">if</span><span class="p">(</span>length<span class="p">(</span>nam<span class="p">)</span><span class="o">==</span><span class="m">0</span><span class="p">)</span> r <span class="kr">else</span> nam
<span class="p">})</span>
library<span class="p">(</span>lattice<span class="p">)</span>
r <span class="o">&lt;-</span> results<span class="p">[</span><span class="m">1</span>:<span class="m">20</span><span class="p">,]</span>
af <span class="o">&lt;-</span> reorder<span class="p">(</span>r<span class="p">$</span>airport<span class="p">,</span>r<span class="p">$</span>all<span class="p">)</span>
dotplot<span class="p">(</span>af~log<span class="p">(</span>r<span class="p">[,</span><span class="s">&#39;all&#39;</span><span class="p">],</span><span class="m">10</span><span class="p">),</span>xlab<span class="o">=</span><span class="s">&#39;Log_10 Total Volume&#39;</span><span class="p">,</span>ylab<span class="o">=</span><span class="s">&#39;Airport&#39;</span><span class="p">,</span>col<span class="o">=</span><span class="s">&#39;black&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>There are 352 locations (airports) of which the top 20 serve 50% of the volume
(see <a class="reference internal" href="#figvolume"><em>Top 20 airports by volume of all flights.</em></a>)</p>
<div class="figure align-center" id="figvolume">
<a class="reference internal image-reference" href="_images/volume.pdf"><img alt="_images/volume.pdf" src="_images/volume.pdf" /></a>
<p class="caption">Top 20 airports by volume of all flights.</p>
</div>
</div>
<div class="section" id="carrier-popularity">
<h3>Carrier Popularity<a class="headerlink" href="#carrier-popularity" title="Permalink to this headline">¶</a></h3>
<p>Some carriers come and go, others demonstrate regular growth. In the following
display, the log base 10 volume (total flights) over years are displayed by
carrier. The carriers are ranked by their median volume (over the 10 year
span).</p>
<p>As mentioned before, RHIPE is mostly boilerplate. Notice the similarities
between this and previous examples (on a side note, to do this for 12GB of data
takes 1 minute and 32 seconds across 72 cores and all the examples, except the
download and conversion to R data frames, in the manual are less than 10 minutes)</p>
<div class="highlight-r"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">## To create summaries</span>
map <span class="o">&lt;-</span> expression<span class="p">({</span>
  a <span class="o">&lt;-</span> do.call<span class="p">(</span><span class="s">&quot;rbind&quot;</span><span class="p">,</span>map.values<span class="p">)</span>
  total <span class="o">&lt;-</span> table<span class="p">(</span>years<span class="o">=</span>a<span class="p">[,</span><span class="s">&#39;year&#39;</span><span class="p">],</span>a<span class="p">[,</span><span class="s">&#39;carrier&#39;</span><span class="p">])</span>
  ac <span class="o">&lt;-</span> rownames<span class="p">(</span>total<span class="p">)</span>
  ys <span class="o">&lt;-</span> colnames<span class="p">(</span>total<span class="p">)</span>
  <span class="kr">for</span><span class="p">(</span>yer in ac<span class="p">){</span>
    <span class="kr">for</span><span class="p">(</span>ca in ys<span class="p">){</span>
      <span class="kr">if</span><span class="p">(</span>total<span class="p">[</span>yer<span class="p">,</span>ca<span class="p">]</span><span class="o">&gt;</span><span class="m">0</span><span class="p">)</span> rhcollect<span class="p">(</span>c<span class="p">(</span>yer<span class="p">,</span>ca<span class="p">),</span> total<span class="p">[</span>yer<span class="p">,</span>ca<span class="p">])</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">})</span>
reduce <span class="o">&lt;-</span> expression<span class="p">(</span>
    pre<span class="o">=</span><span class="p">{</span>sums <span class="o">&lt;-</span> <span class="m">0</span><span class="p">},</span>
    reduce <span class="o">=</span> <span class="p">{</span>sums <span class="o">&lt;-</span> sums<span class="o">+</span>sum<span class="p">(</span>do.call<span class="p">(</span><span class="s">&quot;rbind&quot;</span><span class="p">,</span>reduce.values<span class="p">))},</span>
    post <span class="o">=</span> <span class="p">{</span> rhcollect<span class="p">(</span>reduce.key<span class="p">,</span> sums<span class="p">)</span> <span class="p">}</span>
    <span class="p">)</span>

mapred <span class="o">&lt;-</span> list<span class="p">()</span>
mapred<span class="p">$</span>rhipe_map_buff_size <span class="o">&lt;-</span> <span class="m">5</span>
z <span class="o">&lt;-</span> rhmr<span class="p">(</span>map<span class="o">=</span>map<span class="p">,</span>reduce<span class="o">=</span>reduce<span class="p">,</span>combiner<span class="o">=</span><span class="kc">TRUE</span><span class="p">,</span>inout<span class="o">=</span>c<span class="p">(</span><span class="s">&quot;sequence&quot;</span><span class="p">,</span><span class="s">&quot;sequence&quot;</span><span class="p">)</span>
          <span class="p">,</span>ifolder<span class="o">=</span><span class="s">&quot;/airline/blocks/&quot;</span><span class="p">,</span>ofolder<span class="o">=</span><span class="s">&quot;/airline/carrier.pop&quot;</span>
          <span class="p">,</span>mapred<span class="o">=</span>mapred<span class="p">)</span>
z<span class="o">=</span>rhex<span class="p">(</span>z<span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>This is the RHIPE code to create summaries. We need to extract the data from
Hadoop and create a display</p>
<div class="highlight-r"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34</pre></div></td><td class="code"><div class="highlight"><pre>a <span class="o">&lt;-</span> rhread<span class="p">(</span><span class="s">&quot;/airline/carrier.pop&quot;</span><span class="p">)</span>
head<span class="p">(</span>a<span class="p">)</span>
<span class="p">[[</span><span class="m">1</span><span class="p">]]</span>
<span class="p">[[</span><span class="m">1</span><span class="p">]][[</span><span class="m">1</span><span class="p">]]</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="s">&quot;90&quot;</span> <span class="s">&quot;AA&quot;</span>

<span class="p">[[</span><span class="m">1</span><span class="p">]][[</span><span class="m">2</span><span class="p">]]</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">711825</span>


<span class="p">[[</span><span class="m">2</span><span class="p">]]</span>
<span class="p">[[</span><span class="m">2</span><span class="p">]][[</span><span class="m">1</span><span class="p">]]</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="s">&quot;90&quot;</span> <span class="s">&quot;AS&quot;</span>

yr <span class="o">&lt;-</span> as.numeric<span class="p">(</span>unlist<span class="p">(</span>lapply<span class="p">(</span>lapply<span class="p">(</span>a<span class="p">,</span><span class="s">&quot;[[&quot;</span><span class="p">,</span><span class="m">1</span><span class="p">),</span><span class="s">&quot;[[&quot;</span><span class="p">,</span><span class="m">1</span><span class="p">)))</span>
carrier <span class="o">&lt;-</span> unlist<span class="p">(</span>lapply<span class="p">(</span>lapply<span class="p">(</span>a<span class="p">,</span><span class="s">&quot;[[&quot;</span><span class="p">,</span><span class="m">1</span><span class="p">),</span><span class="s">&quot;[[&quot;</span><span class="p">,</span><span class="m">2</span><span class="p">))</span>
count <span class="o">&lt;-</span> unlist<span class="p">(</span>lapply<span class="p">(</span>a<span class="p">,</span><span class="s">&quot;[[&quot;</span><span class="p">,</span><span class="m">2</span><span class="p">))</span>
results <span class="o">&lt;-</span> data.frame<span class="p">(</span>yr<span class="o">=</span>yr<span class="p">,</span>carcode<span class="o">=</span>carrier<span class="p">,</span>count<span class="o">=</span>count<span class="p">,</span>stringsAsFactors<span class="o">=</span><span class="kc">FALSE</span><span class="p">)</span>
results <span class="o">&lt;-</span> results<span class="p">[</span>order<span class="p">(</span>results<span class="p">$</span>yr<span class="p">,</span>results<span class="p">$</span>count<span class="p">,</span>decreasing<span class="o">=</span><span class="kc">TRUE</span><span class="p">),]</span>
carrier <span class="o">&lt;-</span> read.table<span class="p">(</span><span class="s">&quot;~/tmp/carriers.csv&quot;</span><span class="p">,</span>sep<span class="o">=</span><span class="s">&quot;,&quot;</span><span class="p">,</span>header<span class="o">=</span><span class="kc">TRUE</span><span class="p">,</span>
                      stringsAsFactors<span class="o">=</span><span class="kc">FALSE</span><span class="p">,</span>na.strings<span class="o">=</span><span class="s">&quot;XYZB&quot;</span><span class="p">)</span>
results<span class="p">$</span>carrier <span class="o">&lt;-</span> sapply<span class="p">(</span>results<span class="p">$</span>carcode<span class="p">,</span><span class="kr">function</span><span class="p">(</span>r<span class="p">){</span>
  cd <span class="o">&lt;-</span> carrier<span class="p">[</span>carrier<span class="p">$</span>Code<span class="o">==</span>r<span class="p">,</span><span class="s">&#39;Description&#39;</span><span class="p">]</span>
  <span class="kr">if</span><span class="p">(</span>is.na<span class="p">(</span>cd<span class="p">))</span> r <span class="kr">else</span> cd
<span class="p">})</span>
results<span class="p">$</span>yr <span class="o">&lt;-</span> results<span class="p">$</span>yr<span class="o">+</span><span class="m">1900</span>
carr <span class="o">&lt;-</span> reorder<span class="p">(</span>results<span class="p">$</span>carrier<span class="p">,</span>results<span class="p">$</span>count<span class="p">,</span> median<span class="p">)</span>
xyplot<span class="p">(</span>log<span class="p">(</span>count<span class="p">,</span><span class="m">10</span><span class="p">)</span>~yr<span class="o">|</span>carr<span class="p">,</span> data<span class="o">=</span>results<span class="p">,</span>xlab<span class="o">=</span><span class="s">&quot;Years&quot;</span><span class="p">,</span> ylab<span class="o">=</span><span class="s">&quot;Log10 count&quot;</span><span class="p">,</span>col<span class="o">=</span><span class="s">&#39;black&#39;</span>
        <span class="p">,</span>scales<span class="o">=</span>list<span class="p">(</span>scale<span class="o">=</span><span class="s">&#39;free&#39;</span><span class="p">,</span>tck<span class="o">=</span><span class="m">0.5</span><span class="p">,</span>cex<span class="o">=</span><span class="m">0.7</span><span class="p">),</span>layout<span class="o">=</span>c<span class="p">(</span><span class="m">2</span><span class="p">,</span><span class="m">8</span><span class="p">),</span>type<span class="o">=</span><span class="s">&#39;l&#39;</span>
       <span class="p">,</span>par.strip.text <span class="o">=</span> list<span class="p">(</span>lines <span class="o">=</span> <span class="m">0.8</span><span class="p">,</span>cex<span class="o">=</span><span class="m">0.7</span><span class="p">),</span>cex<span class="o">=</span><span class="m">0.5</span><span class="p">,</span>
       panel<span class="o">=</span><span class="kr">function</span><span class="p">(</span><span class="m">...</span><span class="p">){</span>
         panel.grid<span class="p">(</span>h<span class="o">=</span><span class="m">-1</span><span class="p">,</span>v<span class="o">=</span><span class="m">-1</span><span class="p">)</span>
         panel.xyplot<span class="p">(</span><span class="m">...</span><span class="p">)</span>
       <span class="p">})</span>
</pre></div>
</td></tr></table></div>
<p>The graph is displayed above.</p>
</div>
<div class="section" id="proportion-of-flights-delayed">
<h3>Proportion of Flights Delayed<a class="headerlink" href="#proportion-of-flights-delayed" title="Permalink to this headline">¶</a></h3>
<p>Does this proportion increase with time? Consider the display with proportion of
flights delayed in a day across the years. Each year a panel. 22 panels. A
flight is delayed if the delay is greater than 15 minutes.</p>
<p>It is clear that proportion increases in the holidays (the ends of the
panels). The code for this comes after the figures.</p>
<div class="figure align-center">
<img alt="_images/propdelayed_1.pdf" src="_images/propdelayed_1.pdf" />
<p class="caption">Proportion of flights delayed</p>
</div>
<div class="figure align-center">
<img alt="_images/propdelayed_2.pdf" src="_images/propdelayed_2.pdf" />
<p class="caption">Proportion of flights delayed (cont&#8217;d)</p>
</div>
<div class="highlight-r"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31</pre></div></td><td class="code"><div class="highlight"><pre>map <span class="o">&lt;-</span> expression<span class="p">({</span>
  a <span class="o">&lt;-</span> do.call<span class="p">(</span><span class="s">&quot;rbind&quot;</span><span class="p">,</span>map.values<span class="p">)</span>
  a<span class="p">$</span>delay.sec <span class="o">&lt;-</span> as.vector<span class="p">(</span>a<span class="p">[,</span><span class="s">&#39;arrive&#39;</span><span class="p">])</span><span class="o">-</span>as.vector<span class="p">(</span>a<span class="p">[,</span><span class="s">&#39;sarrive&#39;</span><span class="p">])</span>
  a <span class="o">&lt;-</span> a<span class="p">[</span>!is.na<span class="p">(</span>a<span class="p">$</span>delay.sec<span class="p">),]</span>
  a<span class="p">$</span>isdelayed <span class="o">&lt;-</span> sapply<span class="p">(</span>a<span class="p">$</span>delay.sec<span class="p">,</span><span class="kr">function</span><span class="p">(</span>r<span class="p">)</span> <span class="kr">if</span><span class="p">(</span>r<span class="o">&gt;=</span><span class="m">900</span><span class="p">)</span> <span class="kc">TRUE</span> <span class="kr">else</span> <span class="kc">FALSE</span><span class="p">)</span>
  e <span class="o">&lt;-</span> split<span class="p">(</span>a<span class="p">,</span>list<span class="p">(</span>a<span class="p">$</span>year<span class="p">,</span>a<span class="p">$</span>yday<span class="p">))</span>
  lapply<span class="p">(</span>e<span class="p">,</span><span class="kr">function</span><span class="p">(</span>r<span class="p">){</span>
    n <span class="o">&lt;-</span> nrow<span class="p">(</span>r<span class="p">);</span> numdelayed <span class="o">&lt;-</span> sum<span class="p">(</span>r<span class="p">$</span>isdelayed<span class="p">)</span>
    rhcollect<span class="p">(</span>as.vector<span class="p">(</span>unlist<span class="p">(</span>c<span class="p">(</span>r<span class="p">[</span><span class="m">1</span><span class="p">,</span>c<span class="p">(</span><span class="s">&quot;year&quot;</span><span class="p">,</span><span class="s">&quot;yday&quot;</span><span class="p">)]))),</span> c<span class="p">(</span>n<span class="p">,</span> numdelayed<span class="p">))</span>
  <span class="p">})</span>
<span class="p">})</span>
reduce <span class="o">&lt;-</span> expression<span class="p">(</span>
    pre<span class="o">=</span><span class="p">{</span>sums <span class="o">&lt;-</span> c<span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">0</span><span class="p">)},</span>
    reduce <span class="o">=</span> <span class="p">{</span>sums <span class="o">&lt;-</span> sums<span class="o">+</span>apply<span class="p">(</span>do.call<span class="p">(</span><span class="s">&quot;rbind&quot;</span><span class="p">,</span>reduce.values<span class="p">),</span><span class="m">2</span><span class="p">,</span>sum<span class="p">)},</span>
    post <span class="o">=</span> <span class="p">{</span> rhcollect<span class="p">(</span>reduce.key<span class="p">,</span> sums<span class="p">)</span> <span class="p">}</span>
    <span class="p">)</span>

mapred <span class="o">&lt;-</span> list<span class="p">()</span>
mapred<span class="p">$</span>rhipe_map_buff_size <span class="o">&lt;-</span> <span class="m">5</span>
z <span class="o">&lt;-</span> rhmr<span class="p">(</span>map<span class="o">=</span>map<span class="p">,</span>reduce<span class="o">=</span>reduce<span class="p">,</span>combiner<span class="o">=</span><span class="kc">TRUE</span><span class="p">,</span>inout<span class="o">=</span>c<span class="p">(</span><span class="s">&quot;sequence&quot;</span><span class="p">,</span><span class="s">&quot;sequence&quot;</span><span class="p">)</span>
          <span class="p">,</span>ifolder<span class="o">=</span><span class="s">&quot;/airline/blocks/&quot;</span><span class="p">,</span>ofolder<span class="o">=</span><span class="s">&quot;/airline/delaybyyear&quot;</span>
          <span class="p">,</span>mapred<span class="o">=</span>mapred<span class="p">)</span>
z<span class="o">=</span>rhex<span class="p">(</span>z<span class="p">)</span>

b <span class="o">&lt;-</span> rhread<span class="p">(</span><span class="s">&quot;/airline/delaybyyear&quot;</span><span class="p">)</span>
y1 <span class="o">&lt;-</span> do.call<span class="p">(</span><span class="s">&quot;rbind&quot;</span><span class="p">,</span>lapply<span class="p">(</span>b<span class="p">,</span><span class="s">&quot;[[&quot;</span><span class="p">,</span><span class="m">1</span><span class="p">))</span>
y2 <span class="o">&lt;-</span> do.call<span class="p">(</span><span class="s">&quot;rbind&quot;</span><span class="p">,</span>lapply<span class="p">(</span>b<span class="p">,</span><span class="s">&quot;[[&quot;</span><span class="p">,</span><span class="m">2</span><span class="p">))</span>
results <span class="o">&lt;-</span> data.frame<span class="p">(</span>year<span class="o">=</span><span class="m">1900</span><span class="o">+</span>y1<span class="p">[,</span><span class="m">1</span><span class="p">],</span>yday<span class="o">=</span>y1<span class="p">[,</span><span class="m">2</span><span class="p">],</span>
                      nflight<span class="o">=</span>y2<span class="p">[,</span><span class="m">1</span><span class="p">],</span>ndelay<span class="o">=</span>y2<span class="p">[,</span><span class="m">2</span><span class="p">])</span>
results<span class="p">$</span>prop <span class="o">&lt;-</span> results<span class="p">$</span>ndelay<span class="o">/</span>results<span class="p">$</span>nflight
results <span class="o">&lt;-</span> results<span class="p">[</span>order<span class="p">(</span>results<span class="p">$</span>year<span class="p">,</span>results<span class="p">$</span>yday<span class="p">),]</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference internal" href="#stl-decomposition"><em>STL decomposition of proportion of flights delayed</em></a> is
the STL decomposition of <em>p</em> (the proportion of flights delayed). The <em>seasonal</em>
panel clearly demonstrates the holiday effect of delays. They don&#8217;t seem to be
increasing with time (see <em>trend</em> panel).</p>
<div class="highlight-r"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre>prop <span class="o">&lt;-</span> results<span class="p">[,</span><span class="s">&#39;prop&#39;</span><span class="p">]</span>
prop <span class="o">&lt;-</span> prop<span class="p">[</span>!is.na<span class="p">(</span>prop<span class="p">)]</span>
tprop <span class="o">&lt;-</span> ts<span class="p">(</span>log<span class="p">(</span>prop<span class="o">/</span><span class="p">(</span><span class="m">1</span><span class="o">-</span>prop<span class="p">)),</span>start<span class="o">=</span>c<span class="p">(</span><span class="m">1987</span><span class="p">,</span><span class="m">273</span><span class="p">),</span>frequency<span class="o">=</span><span class="m">365</span><span class="p">)</span>
pdf<span class="p">(</span><span class="s">&quot;~/tmp/propdelayedxyplot.pdf&quot;</span><span class="p">)</span>
plot<span class="p">(</span>stl<span class="p">(</span>tprop<span class="p">,</span>s.window<span class="o">=</span><span class="s">&quot;periodic&quot;</span><span class="p">))</span>
dev.off<span class="p">()</span>
</pre></div>
</td></tr></table></div>
<div class="figure align-center" id="stl-decomposition">
<a class="reference internal image-reference" href="_images/propdelayedxyplot-fromtiff.pdf"><img alt="_images/propdelayedxyplot-fromtiff.pdf" src="_images/propdelayedxyplot-fromtiff.pdf" /></a>
<p class="caption">STL decomposition of proportion of flights delayed</p>
</div>
<p>There is similar seasonality for weekly behavior. The figure <a class="reference internal" href="#delay-by-day-of-week"><em>Proportion of flights delayed by day of week.</em></a> displays proportion of
flights delayed by day of week. The code for this identical to the previous one
except we split on <tt class="docutils literal"><span class="pre">a$wday</span></tt> and the key is <tt class="docutils literal"><span class="pre">r[1,c(&quot;wday&quot;)]</span></tt>. It appears
Thursdays and Fridays can be quite trying.</p>
<div class="figure align-center" id="delay-by-day-of-week">
<a class="reference internal image-reference" href="_images/propdelayeddow.pdf"><img alt="_images/propdelayeddow.pdf" src="_images/propdelayeddow.pdf" /></a>
<p class="caption">Proportion of flights delayed by day of week.</p>
</div>
<p>Does the delay proportion change with hour? It appears it does (see <a class="reference internal" href="#delay-by-hour"><em>Proportion of flights delayed by hour of day</em></a>). The hours are scheduled
departure times. <em>Why are so many flights leaving in the wee hours (12-3) delayed?</em></p>
<div class="figure align-center" id="delay-by-hour">
<a class="reference internal image-reference" href="_images/propdelaybyhour.pdf"><img alt="_images/propdelaybyhour.pdf" src="_images/propdelaybyhour.pdf" /></a>
<p class="caption">Proportion of flights delayed by hour of day</p>
</div>
<p>The code to create <a class="reference internal" href="#delay-by-hour"><em>Proportion of flights delayed by hour of day</em></a> is</p>
<div class="highlight-r"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></div></td><td class="code"><div class="highlight"><pre>map <span class="o">&lt;-</span> expression<span class="p">({</span>
  a <span class="o">&lt;-</span> do.call<span class="p">(</span><span class="s">&quot;rbind&quot;</span><span class="p">,</span>map.values<span class="p">)</span>
  a<span class="p">$</span>delay.sec <span class="o">&lt;-</span> as.vector<span class="p">(</span>a<span class="p">[,</span><span class="s">&#39;arrive&#39;</span><span class="p">])</span><span class="o">-</span>as.vector<span class="p">(</span>a<span class="p">[,</span><span class="s">&#39;sarrive&#39;</span><span class="p">])</span>
  a <span class="o">&lt;-</span> a<span class="p">[</span>!is.na<span class="p">(</span>a<span class="p">$</span>delay.sec<span class="p">),]</span>
  a<span class="p">$</span>isdelayed <span class="o">&lt;-</span> sapply<span class="p">(</span>a<span class="p">$</span>delay.sec<span class="p">,</span><span class="kr">function</span><span class="p">(</span>r<span class="p">)</span> <span class="kr">if</span><span class="p">(</span>r<span class="o">&gt;=</span><span class="m">900</span><span class="p">)</span> <span class="kc">TRUE</span> <span class="kr">else</span> <span class="kc">FALSE</span><span class="p">)</span>
  a<span class="p">$</span>hrs <span class="o">&lt;-</span> as.numeric<span class="p">(</span>format<span class="p">(</span>a<span class="p">[,</span><span class="s">&#39;sdepart&#39;</span><span class="p">],</span><span class="s">&quot;%H&quot;</span><span class="p">))</span>
  e <span class="o">&lt;-</span> split<span class="p">(</span>a<span class="p">,</span>a<span class="p">$</span>hrs<span class="p">)</span>
  lapply<span class="p">(</span>e<span class="p">,</span><span class="kr">function</span><span class="p">(</span>r<span class="p">){</span>
    n <span class="o">&lt;-</span> nrow<span class="p">(</span>r<span class="p">);</span> numdelayed <span class="o">&lt;-</span> sum<span class="p">(</span>r<span class="p">$</span>isdelayed<span class="p">)</span>
    rhcollect<span class="p">(</span>as.vector<span class="p">(</span>unlist<span class="p">(</span>c<span class="p">(</span>r<span class="p">[</span><span class="m">1</span><span class="p">,</span>c<span class="p">(</span><span class="s">&quot;hrs&quot;</span><span class="p">)]))),</span> c<span class="p">(</span>n<span class="p">,</span> numdelayed<span class="p">))</span>
  <span class="p">})</span>
<span class="p">})</span>
reduce <span class="o">&lt;-</span> expression<span class="p">(</span>
    pre<span class="o">=</span><span class="p">{</span>sums <span class="o">&lt;-</span> c<span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">0</span><span class="p">)},</span>
    reduce <span class="o">=</span> <span class="p">{</span>sums <span class="o">&lt;-</span> sums<span class="o">+</span>apply<span class="p">(</span>do.call<span class="p">(</span><span class="s">&quot;rbind&quot;</span><span class="p">,</span>reduce.values<span class="p">),</span><span class="m">2</span><span class="p">,</span>sum<span class="p">)},</span>
    post <span class="o">=</span> <span class="p">{</span> rhcollect<span class="p">(</span>reduce.key<span class="p">,</span> sums<span class="p">)</span> <span class="p">}</span>
    <span class="p">)</span>


mapred <span class="o">&lt;-</span> list<span class="p">()</span>
mapred<span class="p">$</span>rhipe_map_buff_size <span class="o">&lt;-</span> <span class="m">5</span>
z <span class="o">&lt;-</span> rhmr<span class="p">(</span>map<span class="o">=</span>map<span class="p">,</span>reduce<span class="o">=</span>reduce<span class="p">,</span>combiner<span class="o">=</span><span class="kc">TRUE</span><span class="p">,</span>inout<span class="o">=</span>c<span class="p">(</span><span class="s">&quot;sequence&quot;</span><span class="p">,</span><span class="s">&quot;sequence&quot;</span><span class="p">)</span>
          <span class="p">,</span>ifolder<span class="o">=</span><span class="s">&quot;/airline/blocks/&quot;</span><span class="p">,</span>ofolder<span class="o">=</span><span class="s">&quot;/airline/delaybyhours&quot;</span>
          <span class="p">,</span>mapred<span class="o">=</span>mapred<span class="p">)</span>
z<span class="o">=</span>rhex<span class="p">(</span>z<span class="p">)</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="distribution-of-delays">
<h3>Distribution of Delays<a class="headerlink" href="#distribution-of-delays" title="Permalink to this headline">¶</a></h3>
<p>Summaries are not enough and for any sort of modeling we need to look at the
distribution of the data. So onto the quantiles of the delays. We will look at
delays greater than 15 minutes. To compute <em>approximate</em> quantiles for the data,
we simply discretize the delay and compute a frequency count for the unique
values of delay. This is equivalent to binning the data. Given this frequency
table we can compute the quantiles.</p>
<p>The distribution of the delay in minutes does not change significantly over
months.</p>
<div class="highlight-r" id="delay-quantiles-by-month"><span id="index-11"></span><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62</pre></div></td><td class="code"><div class="highlight"><pre>map <span class="o">&lt;-</span> expression<span class="p">({</span>
  a <span class="o">&lt;-</span> do.call<span class="p">(</span><span class="s">&quot;rbind&quot;</span><span class="p">,</span>map.values<span class="p">)</span>
  a<span class="p">$</span>delay.sec <span class="o">&lt;-</span> as.vector<span class="p">(</span>a<span class="p">[,</span><span class="s">&#39;arrive&#39;</span><span class="p">])</span><span class="o">-</span>as.vector<span class="p">(</span>a<span class="p">[,</span><span class="s">&#39;sarrive&#39;</span><span class="p">])</span>
  a <span class="o">&lt;-</span> a<span class="p">[</span>!is.na<span class="p">(</span>a<span class="p">$</span>delay.sec<span class="p">),]</span>
  a<span class="p">$</span>isdelayed <span class="o">&lt;-</span> sapply<span class="p">(</span>a<span class="p">$</span>delay.sec<span class="p">,</span><span class="kr">function</span><span class="p">(</span>r<span class="p">)</span> <span class="kr">if</span><span class="p">(</span>r<span class="o">&gt;=</span><span class="m">900</span><span class="p">)</span> <span class="kc">TRUE</span> <span class="kr">else</span> <span class="kc">FALSE</span><span class="p">)</span>
  a <span class="o">&lt;-</span> a<span class="p">[</span>a<span class="p">$</span>isdelayed<span class="o">==</span><span class="kc">TRUE</span><span class="p">,]</span> <span class="c1">## only look at delays greater than 15 minutes</span>
  apply<span class="p">(</span>a<span class="p">[,</span>c<span class="p">(</span><span class="s">&#39;month&#39;</span><span class="p">,</span><span class="s">&#39;delay.sec&#39;</span><span class="p">)],</span><span class="m">1</span><span class="p">,</span><span class="kr">function</span><span class="p">(</span>r<span class="p">){</span>
        k <span class="o">&lt;-</span> as.vector<span class="p">(</span>unlist<span class="p">(</span>r<span class="p">))</span>
        <span class="kr">if</span><span class="p">(</span>!is.na<span class="p">(</span>k<span class="p">[</span><span class="m">1</span><span class="p">]))</span> rhcollect<span class="p">(</span>k<span class="p">,</span><span class="m">1</span><span class="p">)</span> <span class="c1"># ignore cases where month is missing</span>
      <span class="p">})</span>
<span class="p">})</span>
reduce <span class="o">&lt;-</span> expression<span class="p">(</span>
    pre<span class="o">=</span><span class="p">{</span>sums <span class="o">&lt;-</span> <span class="m">0</span><span class="p">}</span> <span class="p">,</span>
    reduce <span class="o">=</span> <span class="p">{</span>sums <span class="o">&lt;-</span> sums<span class="o">+</span>sum<span class="p">(</span>unlist<span class="p">(</span>reduce.values<span class="p">))},</span>
    post <span class="o">=</span> <span class="p">{</span> rhcollect<span class="p">(</span>reduce.key<span class="p">,</span> sums<span class="p">)</span> <span class="p">}</span>
    <span class="p">)</span>
mapred <span class="o">&lt;-</span> list<span class="p">()</span>
mapred<span class="p">$</span>rhipe_map_buff_size <span class="o">&lt;-</span> <span class="m">5</span>
z <span class="o">&lt;-</span> rhmr<span class="p">(</span>map<span class="o">=</span>map<span class="p">,</span>reduce<span class="o">=</span>reduce<span class="p">,</span>combiner<span class="o">=</span><span class="kc">TRUE</span><span class="p">,</span>inout<span class="o">=</span>c<span class="p">(</span><span class="s">&quot;sequence&quot;</span><span class="p">,</span><span class="s">&quot;sequence&quot;</span><span class="p">)</span>
          <span class="p">,</span>ifolder<span class="o">=</span><span class="s">&quot;/airline/blocks/&quot;</span><span class="p">,</span>ofolder<span class="o">=</span><span class="s">&quot;/airline/quantiledelay&quot;</span>
          <span class="p">,</span>mapred<span class="o">=</span>mapred<span class="p">)</span>
z<span class="o">=</span>rhex<span class="p">(</span>z<span class="p">)</span>
b <span class="o">&lt;-</span> rhread<span class="p">(</span><span class="s">&quot;/airline/quantiledelay&quot;</span><span class="p">)</span>
y1 <span class="o">&lt;-</span> do.call<span class="p">(</span><span class="s">&quot;rbind&quot;</span><span class="p">,</span>lapply<span class="p">(</span>b<span class="p">,</span><span class="s">&quot;[[&quot;</span><span class="p">,</span><span class="m">1</span><span class="p">))</span>
count <span class="o">&lt;-</span> do.call<span class="p">(</span><span class="s">&quot;rbind&quot;</span><span class="p">,</span>lapply<span class="p">(</span>b<span class="p">,</span><span class="s">&quot;[[&quot;</span><span class="p">,</span><span class="m">2</span><span class="p">))</span>
results <span class="o">&lt;-</span> data.frame<span class="p">(</span>month <span class="o">=</span> y1<span class="p">[,</span><span class="m">1</span><span class="p">],</span> n<span class="o">=</span>y1<span class="p">[,</span><span class="m">2</span><span class="p">],</span> count<span class="o">=</span>count<span class="p">)</span>
results <span class="o">&lt;-</span> results<span class="p">[</span>order<span class="p">(</span>results<span class="p">$</span>month<span class="p">,</span> results<span class="p">$</span>n<span class="p">),]</span>
results.2 <span class="o">&lt;-</span> split<span class="p">(</span>results<span class="p">,</span> results<span class="p">$</span>month<span class="p">)</span>

discrete.quantile<span class="o">&lt;-</span><span class="kr">function</span><span class="p">(</span>x<span class="p">,</span>n<span class="p">,</span>prob<span class="o">=</span>seq<span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">0.25</span><span class="p">),</span>type<span class="o">=</span><span class="m">7</span><span class="p">){</span>
  sum.n<span class="o">&lt;-</span>sum<span class="p">(</span>n<span class="p">)</span>
  cum.n<span class="o">&lt;-</span>cumsum<span class="p">(</span>n<span class="p">)</span>
  np<span class="o">&lt;-</span><span class="kr">if</span><span class="p">(</span>type<span class="o">==</span><span class="m">7</span><span class="p">)</span> <span class="p">(</span>sum.n<span class="o">-</span><span class="m">1</span><span class="p">)</span><span class="o">*</span>prob<span class="o">+</span><span class="m">1</span> <span class="kr">else</span> sum.n<span class="o">*</span>prob<span class="o">+</span><span class="m">0.5</span>
  np.fl<span class="o">&lt;-</span>floor<span class="p">(</span>np<span class="p">)</span>
  j1<span class="o">&lt;-</span>pmax<span class="p">(</span>np.fl<span class="p">,</span><span class="m">1</span><span class="p">)</span>
  j2<span class="o">&lt;-</span>pmin<span class="p">(</span>np.fl<span class="o">+</span><span class="m">1</span><span class="p">,</span>sum.n<span class="p">)</span>
  gamma<span class="o">&lt;-</span>np<span class="o">-</span>np.fl
  id1<span class="o">&lt;-</span>unlist<span class="p">(</span>lapply<span class="p">(</span>j1<span class="p">,</span><span class="kr">function</span><span class="p">(</span>r<span class="p">)</span> seq_along<span class="p">(</span>cum.n<span class="p">)[</span>r<span class="o">&lt;=</span>cum.n<span class="p">][</span><span class="m">1</span><span class="p">]))</span>
  id2<span class="o">&lt;-</span>unlist<span class="p">(</span>lapply<span class="p">(</span>j2<span class="p">,</span><span class="kr">function</span><span class="p">(</span>r<span class="p">)</span> seq_along<span class="p">(</span>cum.n<span class="p">)[</span>r<span class="o">&lt;=</span>cum.n<span class="p">][</span><span class="m">1</span><span class="p">]))</span>
  x1<span class="o">&lt;-</span>x<span class="p">[</span>id1<span class="p">]</span>
  x2<span class="o">&lt;-</span>x<span class="p">[</span>id2<span class="p">]</span>
  qntl<span class="o">&lt;-</span><span class="p">(</span><span class="m">1</span><span class="o">-</span>gamma<span class="p">)</span><span class="o">*</span>x1<span class="o">+</span>gamma<span class="o">*</span>x2
  qntl
<span class="p">}</span>

DEL <span class="o">&lt;-</span> <span class="m">0.05</span>
results.3 <span class="o">&lt;-</span> lapply<span class="p">(</span>seq_along<span class="p">(</span>results.2<span class="p">),</span><span class="kr">function</span><span class="p">(</span>i<span class="p">){</span>
  r <span class="o">&lt;-</span> results.2<span class="p">[[</span>i<span class="p">]]</span>
  a <span class="o">&lt;-</span> discrete.quantile<span class="p">(</span>r<span class="p">[,</span><span class="m">2</span><span class="p">],</span>r<span class="p">[,</span><span class="m">3</span><span class="p">],</span>prob<span class="o">=</span>seq<span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">1</span><span class="p">,</span>DEL<span class="p">))</span><span class="o">/</span><span class="m">60</span>
  data.frame<span class="p">(</span>month<span class="o">=</span>as.numeric<span class="p">(</span>rep<span class="p">(</span>names<span class="p">(</span>results.2<span class="p">)[[</span>i<span class="p">]],</span>length<span class="p">(</span>a<span class="p">))),</span>prop<span class="o">=</span>seq<span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">1</span><span class="p">,</span>DEL<span class="p">),</span>qt<span class="o">=</span>a<span class="p">)</span>
<span class="p">})</span>
results.3 <span class="o">&lt;-</span> do.call<span class="p">(</span><span class="s">&quot;rbind&quot;</span><span class="p">,</span>results.3<span class="p">)</span>
results.3<span class="p">$</span>month <span class="o">&lt;-</span> factor<span class="p">(</span>results.3<span class="p">$</span>month<span class="p">,</span>
                          label<span class="o">=</span>c<span class="p">(</span><span class="s">&quot;Jan&quot;</span><span class="p">,</span><span class="s">&quot;Feb&quot;</span><span class="p">,</span><span class="s">&quot;March&quot;</span><span class="p">,</span><span class="s">&quot;Apr&quot;</span><span class="p">,</span><span class="s">&quot;May&quot;</span><span class="p">,</span><span class="s">&quot;June&quot;</span><span class="p">,</span>
                            <span class="s">&quot;July&quot;</span><span class="p">,</span><span class="s">&quot;August&quot;</span><span class="p">,</span><span class="s">&quot;September&quot;</span><span class="p">,</span><span class="s">&quot;October&quot;</span><span class="p">,</span><span class="s">&quot;November&quot;</span><span class="p">,</span><span class="s">&quot;December&quot;</span><span class="p">))</span>
xyplot<span class="p">(</span>log<span class="p">(</span>qt<span class="p">,</span><span class="m">2</span><span class="p">)</span>~prop<span class="o">|</span>month<span class="p">,</span> data<span class="o">=</span>results.3<span class="p">,</span>cex<span class="o">=</span><span class="m">0.4</span><span class="p">,</span>col<span class="o">=</span><span class="s">&#39;black&#39;</span><span class="p">,</span>
       scales<span class="o">=</span>list<span class="p">(</span>x<span class="o">=</span>list<span class="p">(</span>tick.number<span class="o">=</span><span class="m">10</span><span class="p">),</span>y<span class="o">=</span>list<span class="p">(</span>tick.number<span class="o">=</span><span class="m">10</span><span class="p">)),</span>
       layout<span class="o">=</span>c<span class="p">(</span><span class="m">4</span><span class="p">,</span><span class="m">3</span><span class="p">),</span>type<span class="o">=</span><span class="s">&#39;l&#39;</span><span class="p">,</span>
       xlab<span class="o">=</span><span class="s">&quot;Proportion&quot;</span><span class="p">,</span>ylab<span class="o">=</span><span class="s">&quot;log_2 delay (minutes)&quot;</span><span class="p">,</span>panel<span class="o">=</span><span class="kr">function</span><span class="p">(</span>x<span class="p">,</span>y<span class="p">,</span><span class="m">...</span><span class="p">){</span>
         panel.grid<span class="p">(</span>h<span class="o">=</span><span class="m">-1</span><span class="p">,</span>v<span class="o">=</span><span class="m">-1</span><span class="p">);</span>panel.xyplot<span class="p">(</span>x<span class="p">,</span>y<span class="p">,</span><span class="m">...</span><span class="p">)</span>
       <span class="p">}</span>
<span class="p">)</span>
</pre></div>
</td></tr></table></div>
<div class="figure align-center">
<img alt="_images/quantiles_by_month.pdf" src="_images/quantiles_by_month.pdf" />
<p class="caption">Quantile of minute delay (for delay &gt; 15 minutes) across months</p>
</div>
<p>We can display the distribution by hour of day. The code is almost nearly the
same. Differences are in line 8, where the <tt class="docutils literal"><span class="pre">hrs</span></tt> is used as the conditioning.
But the results are more interesting. The delay amounts increase in the wee
hours (look at panel 23,24,1,2 and 3)</p>
<div class="highlight-r"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="highlight"><pre>map <span class="o">&lt;-</span> expression<span class="p">({</span>
  a <span class="o">&lt;-</span> do.call<span class="p">(</span><span class="s">&quot;rbind&quot;</span><span class="p">,</span>map.values<span class="p">)</span>
  a<span class="p">$</span>delay.sec <span class="o">&lt;-</span> as.vector<span class="p">(</span>a<span class="p">[,</span><span class="s">&#39;arrive&#39;</span><span class="p">])</span><span class="o">-</span>as.vector<span class="p">(</span>a<span class="p">[,</span><span class="s">&#39;sarrive&#39;</span><span class="p">])</span>
  a <span class="o">&lt;-</span> a<span class="p">[</span>!is.na<span class="p">(</span>a<span class="p">$</span>delay.sec<span class="p">),]</span>
  a<span class="p">$</span>isdelayed <span class="o">&lt;-</span> sapply<span class="p">(</span>a<span class="p">$</span>delay.sec<span class="p">,</span><span class="kr">function</span><span class="p">(</span>r<span class="p">)</span> <span class="kr">if</span><span class="p">(</span>r<span class="o">&gt;=</span><span class="m">900</span><span class="p">)</span> <span class="kc">TRUE</span> <span class="kr">else</span> <span class="kc">FALSE</span><span class="p">)</span>
  a <span class="o">&lt;-</span> a<span class="p">[</span>a<span class="p">$</span>isdelayed<span class="o">==</span><span class="kc">TRUE</span><span class="p">,]</span> <span class="c1">## only look at delays greater than 15 minutes</span>
  a<span class="p">$</span>hrs <span class="o">&lt;-</span> as.numeric<span class="p">(</span>format<span class="p">(</span>a<span class="p">[,</span><span class="s">&#39;sdepart&#39;</span><span class="p">],</span><span class="s">&quot;%H&quot;</span><span class="p">))</span>
  apply<span class="p">(</span>a<span class="p">[,</span>c<span class="p">(</span><span class="s">&#39;hrs&#39;</span><span class="p">,</span><span class="s">&#39;delay.sec&#39;</span><span class="p">)],</span><span class="m">1</span><span class="p">,</span><span class="kr">function</span><span class="p">(</span>r<span class="p">){</span>
        k <span class="o">&lt;-</span> as.vector<span class="p">(</span>unlist<span class="p">(</span>r<span class="p">))</span>
        <span class="kr">if</span><span class="p">(</span>!is.na<span class="p">(</span>k<span class="p">[</span><span class="m">1</span><span class="p">]))</span> rhcollect<span class="p">(</span>k<span class="p">,</span><span class="m">1</span><span class="p">)</span>
      <span class="p">})</span>
<span class="p">})</span>
reduce <span class="o">&lt;-</span> expression<span class="p">(</span>
    pre<span class="o">=</span><span class="p">{</span>sums <span class="o">&lt;-</span> <span class="m">0</span><span class="p">}</span> <span class="p">,</span>
    reduce <span class="o">=</span> <span class="p">{</span>sums <span class="o">&lt;-</span> sums<span class="o">+</span>sum<span class="p">(</span>unlist<span class="p">(</span>reduce.values<span class="p">))},</span>
    post <span class="o">=</span> <span class="p">{</span> rhcollect<span class="p">(</span>reduce.key<span class="p">,</span> sums<span class="p">)</span> <span class="p">}</span>
    <span class="p">)</span>

mapred <span class="o">&lt;-</span> list<span class="p">()</span>
mapred<span class="p">$</span>rhipe_map_buff_size <span class="o">&lt;-</span> <span class="m">5</span>
z <span class="o">&lt;-</span> rhmr<span class="p">(</span>map<span class="o">=</span>map<span class="p">,</span>reduce<span class="o">=</span>reduce<span class="p">,</span>combiner<span class="o">=</span><span class="kc">TRUE</span><span class="p">,</span>inout<span class="o">=</span>c<span class="p">(</span><span class="s">&quot;sequence&quot;</span><span class="p">,</span><span class="s">&quot;sequence&quot;</span><span class="p">)</span>
          <span class="p">,</span>ifolder<span class="o">=</span><span class="s">&quot;/airline/blocks/&quot;</span><span class="p">,</span>ofolder<span class="o">=</span><span class="s">&quot;/airline/quantiledelaybyhour&quot;</span>
          <span class="p">,</span>mapred<span class="o">=</span>mapred<span class="p">)</span>
z<span class="o">=</span>rhex<span class="p">(</span>z<span class="p">)</span>
</pre></div>
</td></tr></table></div>
<div class="figure align-center">
<img alt="_images/quantiles_by_hr_1.pdf" src="_images/quantiles_by_hr_1.pdf" />
<p class="caption">Quantile of minute delay (for delay &gt; 15 minutes) by hour of day</p>
</div>
<div class="figure align-center">
<img alt="_images/quantiles_by_hr_2.pdf" src="_images/quantiles_by_hr_2.pdf" />
<p class="caption">Quantile of minute delay (for delay &gt; 15 minutes) by hour of day (cont&#8217;d)</p>
</div>
<p>The distribution of delay times by airports. This could be analyzed for several
airports, but we take the top 3 in terms of volumes. In this display, the
quantiles of log_2 of the delay times (in minutes) for inbound and outbound for
4 different airports is plotted. The airports are in order of median delay time.
Of note, the median delay time for Chicago (ORD) and San Francisco (SFO) is greater flying in than out
(approximately an hour). For both Chicago and Dallas Fort Worth (DFW), the 75th
percentile of inbound delays is greater than that for outbound. <a class="reference internal" href="#quantilebyairport"><em>Quantile of minute delay for inbound and outbound for 4 different
airports. Dotted red lines are 25%,50% and 75% uniform proportions.</em></a> displays these differences.</p>
<div class="highlight-r"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29</pre></div></td><td class="code"><div class="highlight"><pre> map <span class="o">&lt;-</span> expression<span class="p">({</span>
   cc <span class="o">&lt;-</span> c<span class="p">(</span><span class="s">&quot;ORD&quot;</span><span class="p">,</span><span class="s">&quot;SEA&quot;</span><span class="p">,</span><span class="s">&quot;DFW&quot;</span><span class="p">,</span><span class="s">&quot;SFO&quot;</span><span class="p">)</span>
   a <span class="o">&lt;-</span> do.call<span class="p">(</span><span class="s">&quot;rbind&quot;</span><span class="p">,</span>map.values<span class="p">)</span>
   a <span class="o">&lt;-</span> a<span class="p">[</span>a<span class="p">$</span>origin <span class="o">%in%</span> cc<span class="o">|</span> a<span class="p">$</span>dest <span class="o">%in%</span> cc<span class="p">,]</span>
   <span class="kr">if</span><span class="p">(</span>nrow<span class="p">(</span>a<span class="p">)</span><span class="o">&gt;</span><span class="m">0</span><span class="p">){</span>
     a<span class="p">$</span>delay.sec <span class="o">&lt;-</span> as.vector<span class="p">(</span>a<span class="p">[,</span><span class="s">&#39;arrive&#39;</span><span class="p">])</span><span class="o">-</span>as.vector<span class="p">(</span>a<span class="p">[,</span><span class="s">&#39;sarrive&#39;</span><span class="p">])</span>
     a <span class="o">&lt;-</span> a<span class="p">[</span>!is.na<span class="p">(</span>a<span class="p">$</span>delay.sec<span class="p">),]</span>
     a<span class="p">$</span>isdelayed <span class="o">&lt;-</span> sapply<span class="p">(</span>a<span class="p">$</span>delay.sec<span class="p">,</span><span class="kr">function</span><span class="p">(</span>r<span class="p">)</span> <span class="kr">if</span><span class="p">(</span>r<span class="o">&gt;=</span><span class="m">900</span><span class="p">)</span> <span class="kc">TRUE</span> <span class="kr">else</span> <span class="kc">FALSE</span><span class="p">)</span>
     a <span class="o">&lt;-</span> a<span class="p">[</span>a<span class="p">$</span>isdelayed<span class="o">==</span><span class="kc">TRUE</span><span class="p">,]</span>
     <span class="kr">for</span><span class="p">(</span>i in <span class="m">1</span>:nrow<span class="p">(</span>a<span class="p">)){</span>
       dl <span class="o">&lt;-</span> a<span class="p">[</span>i<span class="p">,</span><span class="s">&#39;delay.sec&#39;</span><span class="p">]</span>
       <span class="kr">if</span><span class="p">(</span>a<span class="p">[</span>i<span class="p">,</span><span class="s">&#39;origin&#39;</span><span class="p">]</span> <span class="o">%in%</span> cc<span class="p">)</span> rhcollect<span class="p">(</span>data.frame<span class="p">(</span>dir<span class="o">=</span><span class="s">&quot;outbound&quot;</span><span class="p">,</span>ap<span class="o">=</span>a<span class="p">[</span>i<span class="p">,</span><span class="s">&quot;origin&quot;</span><span class="p">]</span>
                                                      <span class="p">,</span>delay<span class="o">=</span>dl<span class="p">,</span>stringsAsFactors<span class="o">=</span><span class="kc">FALSE</span><span class="p">),</span><span class="m">1</span><span class="p">)</span>
       <span class="kr">if</span><span class="p">(</span>a<span class="p">[</span>i<span class="p">,</span><span class="s">&#39;dest&#39;</span><span class="p">]</span> <span class="o">%in%</span> cc<span class="p">)</span> rhcollect<span class="p">(</span>data.frame<span class="p">(</span>dir<span class="o">=</span><span class="s">&quot;inbound&quot;</span><span class="p">,</span>ap<span class="o">=</span>a<span class="p">[</span>i<span class="p">,</span><span class="s">&quot;dest&quot;</span><span class="p">]</span>
                                               <span class="p">,</span>delay<span class="o">=</span>dl<span class="p">,</span>stringsAsFactors<span class="o">=</span><span class="kc">FALSE</span><span class="p">),</span><span class="m">1</span><span class="p">)</span>
     <span class="p">}</span>
   <span class="p">}</span>
 <span class="p">})</span>
reduce <span class="o">&lt;-</span> expression<span class="p">(</span>
     pre<span class="o">=</span><span class="p">{</span>sums <span class="o">&lt;-</span> <span class="m">0</span><span class="p">}</span> <span class="p">,</span>
     reduce <span class="o">=</span> <span class="p">{</span>sums <span class="o">&lt;-</span> sums<span class="o">+</span>sum<span class="p">(</span>unlist<span class="p">(</span>reduce.values<span class="p">))},</span>
     post <span class="o">=</span> <span class="p">{</span> rhcollect<span class="p">(</span>reduce.key<span class="p">,</span> sums<span class="p">)</span> <span class="p">}</span>
     <span class="p">)</span>
 mapred <span class="o">&lt;-</span> list<span class="p">()</span>
 mapred<span class="p">$</span>rhipe_map_buff_size <span class="o">&lt;-</span> <span class="m">5</span>
 z <span class="o">&lt;-</span> rhmr<span class="p">(</span>map<span class="o">=</span>map<span class="p">,</span>reduce<span class="o">=</span>reduce<span class="p">,</span>combiner<span class="o">=</span><span class="kc">TRUE</span><span class="p">,</span>inout<span class="o">=</span>c<span class="p">(</span><span class="s">&quot;sequence&quot;</span><span class="p">,</span><span class="s">&quot;sequence&quot;</span><span class="p">)</span>
           <span class="p">,</span>ifolder<span class="o">=</span><span class="s">&quot;/airline/blocks/&quot;</span><span class="p">,</span>ofolder<span class="o">=</span><span class="s">&quot;/airline/inoutboundelay&quot;</span>
           <span class="p">,</span>mapred<span class="o">=</span>mapred<span class="p">)</span>
 z<span class="o">=</span>rhex<span class="p">(</span>z<span class="p">)</span>
</pre></div>
</td></tr></table></div>
<div class="figure align-center" id="quantilebyairport">
<img alt="_images/quantiles_by_airport.pdf" src="_images/quantiles_by_airport.pdf" />
<p class="caption">Quantile of minute delay for inbound and outbound for 4 different
airports. Dotted red lines are 25%,50% and 75% uniform proportions.</p>
</div>
</div>
<div class="section" id="carrier-delays">
<h3>Carrier Delays<a class="headerlink" href="#carrier-delays" title="Permalink to this headline">¶</a></h3>
<p>Is there a difference in carrier delays? We display the time series of
proportion of delayed flights by carrier, ranked by carrier.</p>
<div class="highlight-r"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">## For proportions and volumes</span>
map <span class="o">&lt;-</span> expression<span class="p">({</span>
  a <span class="o">&lt;-</span> do.call<span class="p">(</span><span class="s">&quot;rbind&quot;</span><span class="p">,</span>map.values<span class="p">)</span>
  a<span class="p">$</span>delay.sec <span class="o">&lt;-</span> as.vector<span class="p">(</span>a<span class="p">[,</span><span class="s">&#39;arrive&#39;</span><span class="p">])</span><span class="o">-</span>as.vector<span class="p">(</span>a<span class="p">[,</span><span class="s">&#39;sarrive&#39;</span><span class="p">])</span>
  a <span class="o">&lt;-</span> a<span class="p">[</span>!is.na<span class="p">(</span>a<span class="p">$</span>delay.sec<span class="p">),]</span>
  a<span class="p">$</span>isdelayed <span class="o">&lt;-</span> sapply<span class="p">(</span>a<span class="p">$</span>delay.sec<span class="p">,</span><span class="kr">function</span><span class="p">(</span>r<span class="p">)</span> <span class="kr">if</span><span class="p">(</span>r<span class="o">&gt;=</span><span class="m">900</span><span class="p">)</span> <span class="kc">TRUE</span> <span class="kr">else</span> <span class="kc">FALSE</span><span class="p">)</span>
  a<span class="p">$</span>hrs <span class="o">&lt;-</span> as.numeric<span class="p">(</span>format<span class="p">(</span>a<span class="p">[,</span><span class="s">&#39;sdepart&#39;</span><span class="p">],</span><span class="s">&quot;%H&quot;</span><span class="p">))</span>
  e <span class="o">&lt;-</span> split<span class="p">(</span>a<span class="p">,</span>a<span class="p">$</span>hrs<span class="p">)</span>
  lapply<span class="p">(</span>e<span class="p">,</span><span class="kr">function</span><span class="p">(</span>r<span class="p">){</span>
    n <span class="o">&lt;-</span> nrow<span class="p">(</span>r<span class="p">);</span> numdelayed <span class="o">&lt;-</span> sum<span class="p">(</span>r<span class="p">$</span>isdelayed<span class="p">)</span>
    rhcollect<span class="p">(</span>as.vector<span class="p">(</span>unlist<span class="p">(</span>c<span class="p">(</span>r<span class="p">[</span><span class="m">1</span><span class="p">,</span>c<span class="p">(</span><span class="s">&quot;carrier&quot;</span><span class="p">)]))),</span> c<span class="p">(</span>n<span class="p">,</span> numdelayed<span class="p">))</span>
  <span class="p">})</span>
<span class="p">})</span>
reduce <span class="o">&lt;-</span> expression<span class="p">(</span>
    pre<span class="o">=</span><span class="p">{</span>sums <span class="o">&lt;-</span> c<span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">0</span><span class="p">)},</span>
    reduce <span class="o">=</span> <span class="p">{</span>sums <span class="o">&lt;-</span> sums<span class="o">+</span>apply<span class="p">(</span>do.call<span class="p">(</span><span class="s">&quot;rbind&quot;</span><span class="p">,</span>reduce.values<span class="p">),</span><span class="m">2</span><span class="p">,</span>sum<span class="p">)},</span>
    post <span class="o">=</span> <span class="p">{</span> rhcollect<span class="p">(</span>reduce.key<span class="p">,</span> sums<span class="p">)</span> <span class="p">}</span>
    <span class="p">)</span>
</pre></div>
</td></tr></table></div>
<div class="figure align-center">
<img alt="_images/carrvol.pdf" src="_images/carrvol.pdf" />
<p class="caption">Log base 2 volume of flights by carrier</p>
</div>
<div class="figure align-center">
<img alt="_images/carrdelay.pdf" src="_images/carrdelay.pdf" />
<p class="caption">Proportion of flights delayed by carrier. Compare this with the previous graph.</p>
</div>
</div>
<div class="section" id="busy-routes">
<h3>Busy Routes<a class="headerlink" href="#busy-routes" title="Permalink to this headline">¶</a></h3>
<p>Which are busy the routes? A simple first approach (for display purposed) is to
create a frequency table for the unordered pair <em>(i,j)</em> where <em>i</em> and <em>j</em> are
distinct airport codes. Displays this over the US map.</p>
<div class="highlight-r"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50</pre></div></td><td class="code"><div class="highlight"><pre>map <span class="o">&lt;-</span> expression<span class="p">({</span>
  a <span class="o">&lt;-</span> do.call<span class="p">(</span><span class="s">&quot;rbind&quot;</span><span class="p">,</span>map.values<span class="p">)</span>
  y <span class="o">&lt;-</span> table<span class="p">(</span>apply<span class="p">(</span>a<span class="p">[,</span>c<span class="p">(</span><span class="s">&quot;origin&quot;</span><span class="p">,</span><span class="s">&quot;dest&quot;</span><span class="p">)],</span><span class="m">1</span><span class="p">,</span><span class="kr">function</span><span class="p">(</span>r<span class="p">){</span>
    paste<span class="p">(</span>sort<span class="p">(</span>r<span class="p">),</span>collapse<span class="o">=</span><span class="s">&quot;,&quot;</span><span class="p">)</span>
  <span class="p">}))</span>
  <span class="kr">for</span><span class="p">(</span>i in <span class="m">1</span>:length<span class="p">(</span>y<span class="p">)){</span>
    p <span class="o">&lt;-</span> strsplit<span class="p">(</span>names<span class="p">(</span>y<span class="p">)[[</span>i<span class="p">]],</span><span class="s">&quot;,&quot;</span><span class="p">)[[</span><span class="m">1</span><span class="p">]]</span>
    rhcollect<span class="p">(</span>p<span class="p">,</span>y<span class="p">[[</span><span class="m">1</span><span class="p">]])</span>
  <span class="p">}</span>
<span class="p">})</span>
reduce <span class="o">&lt;-</span> expression<span class="p">(</span>
    pre<span class="o">=</span><span class="p">{</span>sums <span class="o">&lt;-</span> <span class="m">0</span><span class="p">},</span>
    reduce <span class="o">=</span> <span class="p">{</span>sums <span class="o">&lt;-</span> sums<span class="o">+</span>sum<span class="p">(</span>unlist<span class="p">(</span>reduce.values<span class="p">))},</span>
    post <span class="o">=</span> <span class="p">{</span> rhcollect<span class="p">(</span>reduce.key<span class="p">,</span> sums<span class="p">)</span> <span class="p">}</span>
    <span class="p">)</span>
mapred <span class="o">&lt;-</span> list<span class="p">()</span>
mapred<span class="p">$</span>rhipe_map_buff_size <span class="o">&lt;-</span> <span class="m">5</span>
mapred<span class="p">$</span>mapred.job.priority<span class="o">=</span><span class="s">&quot;VERY_LOW&quot;</span>
z <span class="o">&lt;-</span> rhmr<span class="p">(</span>map<span class="o">=</span>map<span class="p">,</span>reduce<span class="o">=</span>reduce<span class="p">,</span>combiner<span class="o">=</span><span class="kc">TRUE</span><span class="p">,</span>inout<span class="o">=</span>c<span class="p">(</span><span class="s">&quot;sequence&quot;</span><span class="p">,</span><span class="s">&quot;sequence&quot;</span><span class="p">)</span>
          <span class="p">,</span>ifolder<span class="o">=</span><span class="s">&quot;/airline/blocks/&quot;</span><span class="p">,</span>ofolder<span class="o">=</span><span class="s">&quot;/airline/ijjoin&quot;</span>
          <span class="p">,</span>mapred<span class="o">=</span>mapred<span class="p">)</span>
z<span class="o">=</span>rhex<span class="p">(</span>z<span class="p">)</span>

<span class="c1">##Merge results</span>
b<span class="o">=</span>rhread<span class="p">(</span><span class="s">&quot;/airline/ijjoin&quot;</span><span class="p">)</span>
y <span class="o">&lt;-</span> do.call<span class="p">(</span><span class="s">&quot;rbind&quot;</span><span class="p">,</span>lapply<span class="p">(</span>b<span class="p">,</span><span class="s">&quot;[[&quot;</span><span class="p">,</span><span class="m">1</span><span class="p">))</span>
results <span class="o">&lt;-</span> data.frame<span class="p">(</span>a<span class="o">=</span>y<span class="p">[,</span><span class="m">1</span><span class="p">],</span>b<span class="o">=</span>y<span class="p">[,</span><span class="m">2</span><span class="p">],</span>count<span class="o">=</span>
           do.call<span class="p">(</span><span class="s">&quot;rbind&quot;</span><span class="p">,</span>lapply<span class="p">(</span>b<span class="p">,</span><span class="s">&quot;[[&quot;</span><span class="p">,</span><span class="m">2</span><span class="p">)),</span>stringsAsFactors<span class="o">=</span><span class="kc">FALSE</span><span class="p">)</span>
results <span class="o">&lt;-</span> results<span class="p">[</span>order<span class="p">(</span>results<span class="p">$</span>count<span class="p">,</span>decreasing<span class="o">=</span><span class="kc">TRUE</span><span class="p">),]</span>
results<span class="p">$</span>cumprop <span class="o">&lt;-</span> cumsum<span class="p">(</span>results<span class="p">$</span>count<span class="p">)</span><span class="o">/</span>sum<span class="p">(</span>results<span class="p">$</span>count<span class="p">)</span>
a.lat <span class="o">&lt;-</span> t<span class="p">(</span>sapply<span class="p">(</span>results<span class="p">$</span>a<span class="p">,</span><span class="kr">function</span><span class="p">(</span>r<span class="p">){</span>
  ap<span class="p">[</span>ap<span class="p">$</span>iata<span class="o">==</span>r<span class="p">,</span>c<span class="p">(</span><span class="s">&#39;lat&#39;</span><span class="p">,</span><span class="s">&#39;long&#39;</span><span class="p">)]</span>
<span class="p">}))</span>
results<span class="p">$</span>a.lat <span class="o">&lt;-</span> unlist<span class="p">(</span>a.lat<span class="p">[,</span><span class="s">&#39;lat&#39;</span><span class="p">])</span>
results<span class="p">$</span>a.long <span class="o">&lt;-</span> unlist<span class="p">(</span>a.lat<span class="p">[,</span><span class="s">&#39;long&#39;</span><span class="p">])</span>
b.lat <span class="o">&lt;-</span> t<span class="p">(</span>sapply<span class="p">(</span>results<span class="p">$</span>b<span class="p">,</span><span class="kr">function</span><span class="p">(</span>r<span class="p">){</span>
  ap<span class="p">[</span>ap<span class="p">$</span>iata<span class="o">==</span>r<span class="p">,</span>c<span class="p">(</span><span class="s">&#39;lat&#39;</span><span class="p">,</span><span class="s">&#39;long&#39;</span><span class="p">)]</span>
<span class="p">}))</span>
b.lat<span class="p">[</span><span class="s">&quot;CBM&quot;</span><span class="p">,]</span> <span class="o">&lt;-</span> c<span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">0</span><span class="p">)</span>
results<span class="p">$</span>b.lat <span class="o">&lt;-</span> unlist<span class="p">(</span>b.lat<span class="p">[,</span><span class="s">&#39;lat&#39;</span><span class="p">])</span>
results<span class="p">$</span>b.long <span class="o">&lt;-</span> unlist<span class="p">(</span>b.lat<span class="p">[,</span><span class="s">&#39;long&#39;</span><span class="p">])</span>

head<span class="p">(</span>results<span class="p">)</span>
   a   b  count     cumprop    a.lat     a.long    b.lat     b.long
<span class="m">1</span> ATL ORD <span class="m">145810</span> <span class="m">0.001637867</span> <span class="m">33.64044</span>  <span class="m">-84.42694</span> <span class="m">41.97960</span>  <span class="m">-87.90446</span>
<span class="m">2</span> LAS LAX <span class="m">140722</span> <span class="m">0.003218581</span> <span class="m">36.08036</span> <span class="m">-115.15233</span> <span class="m">33.94254</span> <span class="m">-118.40807</span>
<span class="m">3</span> DEN DFW <span class="m">140258</span> <span class="m">0.004794083</span> <span class="m">39.85841</span> <span class="m">-104.66700</span> <span class="m">32.89595</span>  <span class="m">-97.03720</span>
<span class="m">4</span> LAX SFO <span class="m">139427</span> <span class="m">0.006360250</span> <span class="m">33.94254</span> <span class="m">-118.40807</span> <span class="m">37.61900</span> <span class="m">-122.37484</span>
<span class="m">5</span> DFW IAH <span class="m">137004</span> <span class="m">0.007899200</span> <span class="m">32.89595</span>  <span class="m">-97.03720</span> <span class="m">29.98047</span>  <span class="m">-95.33972</span>
<span class="m">6</span> DTW ORD <span class="m">135772</span> <span class="m">0.009424311</span> <span class="m">42.21206</span>  <span class="m">-83.34884</span> <span class="m">41.97960</span>  <span class="m">-87.90446</span>
</pre></div>
</td></tr></table></div>
<p>Using the above data, the following figure draws lines from ORD (Chicago) to
other destinations. The black points are the airports that handle 90% of the
total air traffic volume. The grey points are the remaining airports. The
flights from Chicago (ORD) are color coded based on volume carried e.g. red
implies those routes carry the top 25% of traffic in/out of ORD.</p>
<div class="figure align-center">
<img alt="_images/flightord.pdf" src="_images/flightord.pdf" />
<p class="caption">Flights in and out of Chicago color coded by % cumulative contribution.</p>
</div>
</div>
</div>
<div class="section" id="out-of-core-regression-using-biglm">
<span id="out-of-core-regression"></span><span id="index-12"></span><h2>Out of Core Regression using <tt class="docutils literal"><span class="pre">biglm</span></tt><a class="headerlink" href="#out-of-core-regression-using-biglm" title="Permalink to this headline">¶</a></h2>
<p>RHIPE can be used as a means to transfer massive data sets sitting on the HDFS to the package <a class="reference internal" href="#biglm">[biglm]</a>
<tt class="docutils literal"><span class="pre">biglm</span></tt> takes a function that returns chunks of data frames. We can easily use this to compute the results of a linear
regression on the airline data set. These functions work assuming the values are chunked data frames
as the airline data set is stored (see above).</p>
<table class="docutils citation" frame="void" id="biglm" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[biglm]</a></td><td>biglm: bounded memory linear and generalized linear models <a class="reference external" href="http://cran.r-project.org/web/packages/biglm/index.html">http://cran.r-project.org/web/packages/biglm/index.html</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="streaming-data">
<span id="id7"></span><h2>Streaming Data?<a class="headerlink" href="#streaming-data" title="Permalink to this headline">¶</a></h2>
<p id="index-13">Some algorithms are left associative in their operands
<img class="math" src="_images/math/a2baafd5b1e0d0bf06be1664d5e368887ea65223.png" alt="t_1,t_2,\ldots,t_n"/> but not commutative. For example a streaming update
algorithm that computes the inter-arrival times of time series data for
different levels of a categorical variable. That is, the triangular series
<img class="math" src="_images/math/ba9d13024156b70b27d9f1749e787fe68637e1c5.png" alt="t_{k,1},t_{k,2},\ldots,t_{k,n_k}"/> where <em>k</em> takes the levels of a
categorical variable <em>C</em> (which takes the values <img class="math" src="_images/math/b658261bf4824cafc74ea87a9e719f1e48211816.png" alt="1,2,3,\ldots,m"/>). The
input are pairs <img class="math" src="_images/math/898a23a47dc612f785069a9896621219ad6d0147.png" alt="(i,j), i \in \{1,2,\ldots,m\}, j \in \{t_{ik}\}"/>
. In the following code, the data structure <em>F</em> is updated with the
<em>datastructure</em> contained in the values (see the map). The <em>datastructures</em>
are indexed in time by the <em>timepoint</em> - they need to be sent to the reducer
(for a given level of the categorical variable <em>catlevel</em>) in time order. Thus
the map sends the pair <tt class="docutils literal"><span class="pre">(catlevel,</span> <span class="pre">timepoint)</span></tt> as the key. By using the
<tt class="docutils literal"><span class="pre">part</span></tt> parameter (see line 39) <em>all</em> the data structures associated with the <tt class="docutils literal"><span class="pre">catlevel</span></tt>
are sent to the same R reduce process. This is vital since all the component
R expressions in the reduce are run in the same process and namespace. To
preserve numeric ordering we insist on the special map output key class (see
line 38). With this special key class, we cannot have a map output format.
In the reduce, the setup expression <tt class="docutils literal"><span class="pre">redsetup</span></tt> is run upon R startup (the
process assigned to several keys and their associated values). Then for each new
intermediate key <tt class="docutils literal"><span class="pre">(catlevel,</span> <span class="pre">timepoint)</span></tt>, it runs the <tt class="docutils literal"><span class="pre">pre</span></tt>, <tt class="docutils literal"><span class="pre">reduce</span></tt> and
<tt class="docutils literal"><span class="pre">post</span></tt>. The lack of a <tt class="docutils literal"><span class="pre">post</span></tt> is because we have exactly one intermediate
value for a given key (assuming the time points for a category are unique).
The <tt class="docutils literal"><span class="pre">redclose</span></tt> expression is run when all keys and values have been processed
by the reducer and R is about to quit.</p>
<div class="highlight-r"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39</pre></div></td><td class="code"><div class="highlight"><pre>map <span class="o">&lt;-</span> expression<span class="p">({</span>
   lapply<span class="p">(</span>seq_along<span class="p">(</span>map.values<span class="p">),</span><span class="kr">function</span><span class="p">(</span>r<span class="p">){</span>
     catlevel <span class="o">&lt;-</span> map.keys<span class="p">[[</span>r<span class="p">]]</span> <span class="c1">#numeric</span>
     timepoint <span class="o">&lt;-</span> map.values<span class="p">[[</span>r<span class="p">]]$</span>timepoint <span class="c1">#numeric</span>
     datastructure <span class="o">&lt;-</span> map.values<span class="p">[[</span>r<span class="p">]]$</span>data
     key <span class="o">&lt;-</span> c<span class="p">(</span>catlevel<span class="p">,</span>timepoint<span class="p">)</span>
     rhcollect<span class="p">(</span>key<span class="p">,</span>datastructure<span class="p">)</span>
   <span class="p">})</span>
 <span class="p">})</span>
 redsetup <span class="o">&lt;-</span> expression<span class="p">({</span>
   currentkey <span class="o">&lt;-</span> <span class="kc">NULL</span>
 <span class="p">})</span>
 reduce <span class="o">&lt;-</span> expression<span class="p">(</span>
     pre<span class="o">=</span><span class="p">{</span>
       catlevel <span class="o">&lt;-</span> reduce.key<span class="p">[</span><span class="m">1</span><span class="p">]</span>
       time <span class="o">&lt;-</span> reduce.key<span class="p">[</span><span class="m">2</span><span class="p">]</span>
       <span class="kr">if</span><span class="p">(</span>!identical<span class="p">(</span>catlevel<span class="p">,</span>currentkey<span class="p">)){</span>
         <span class="c1">## new categorical level</span>
         <span class="c1">## so finalize the computation for</span>
         <span class="c1">## the previous level e.g. use rhcollect</span>
         <span class="kr">if</span><span class="p">(</span>!identical<span class="p">(</span>currentkey<span class="p">,</span><span class="kc">NULL</span><span class="p">))</span>
           FINALIZE<span class="p">(</span><span class="k-Variable">F</span><span class="p">)</span>
         <span class="c1">## store current categorical level</span>
         currentkey <span class="o">&lt;-</span> catlevel
         <span class="c1">## initialize computation for new level</span>
         INITIALIZE<span class="p">(</span><span class="k-Variable">F</span><span class="p">)</span>
       <span class="p">}</span>
     <span class="p">},</span>
     reduce<span class="o">=</span><span class="p">{</span>
       <span class="k-Variable">F</span> <span class="o">&lt;-</span> UPDATE<span class="p">(</span><span class="k-Variable">F</span><span class="p">,</span> reduce.values<span class="p">[[</span><span class="m">1</span><span class="p">]])</span>
     <span class="p">})</span>
 redclose <span class="o">&lt;-</span> expression<span class="p">({</span>
   <span class="c1">## need to run this, otherwise the last catlevel</span>
   <span class="c1">## will not get finalized</span>
  FINALIZE<span class="p">(</span><span class="k-Variable">F</span><span class="p">)</span>
 <span class="p">})</span>
 rhmr<span class="p">(</span><span class="m">...</span><span class="p">,</span> combiner<span class="o">=</span><span class="kc">FALSE</span><span class="p">,</span>setup<span class="o">=</span>list<span class="p">(</span>reduce<span class="o">=</span>redsetup<span class="p">),</span>cleanup<span class="o">=</span>list<span class="p">(</span>reduce<span class="o">=</span>redclose<span class="p">),</span>
      orderby<span class="o">=</span><span class="s">&quot;numeric&quot;</span><span class="p">,</span>
      part<span class="o">=</span>list<span class="p">(</span>lims<span class="o">=</span><span class="m">1</span><span class="p">,</span>type<span class="o">=</span><span class="s">&#39;numeric&#39;</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<div class="section" id="concrete-but-artifical-example">
<h3>Concrete (but artifical) Example<a class="headerlink" href="#concrete-but-artifical-example" title="Permalink to this headline">¶</a></h3>
<p>We will create a data set with three columns: the level of a categorical
variable <em>A</em>, a time variable <em>B</em> and a value <em>C</em>. For each level of <em>A</em>, we
want the sum of differences of <em>C</em> ordered by <em>B</em> within <em>A</em>.</p>
<p><strong>Creating the Data set</strong> The column <em>A</em> is the key, but this is not important. There are 5000 levels of <em>A</em>, each level has 10,000 observations. By design the values of <em>B</em> are randomly written (<tt class="docutils literal"><span class="pre">sample</span></tt>), also for simplicity <em>C</em> is equal to <em>B</em>, though this need not be.</p>
<div class="highlight-r"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre>library<span class="p">(</span>Rhipe<span class="p">)</span>
map <span class="o">&lt;-</span> expression<span class="p">({</span>
  N <span class="o">&lt;-</span> <span class="m">10000</span>
  <span class="kr">for</span><span class="p">(</span> first.col in map.values <span class="p">){</span>
    w <span class="o">&lt;-</span> sample<span class="p">(</span>N<span class="p">,</span>N<span class="p">,</span>replace<span class="o">=</span><span class="kc">FALSE</span><span class="p">)</span>
    <span class="kr">for</span><span class="p">(</span> i in w<span class="p">){</span>
      rhcollect<span class="p">(</span>first.col<span class="p">,</span>c<span class="p">(</span>i<span class="p">,</span>i<span class="p">))</span>
    <span class="p">}</span>
  <span class="p">}})</span>
mapred <span class="o">&lt;-</span> list<span class="p">(</span>mapred.reduce.tasks<span class="o">=</span><span class="m">0</span><span class="p">)</span>
z<span class="o">=</span>rhmr<span class="p">(</span>map<span class="o">=</span>map<span class="p">,</span> N<span class="o">=</span><span class="m">5000</span><span class="p">,</span> inout<span class="o">=</span>c<span class="p">(</span><span class="s">&quot;lapply&quot;</span><span class="p">,</span><span class="s">&quot;sequence&quot;</span><span class="p">),</span>ofolder<span class="o">=</span><span class="s">&quot;/tmp/sort&quot;</span><span class="p">,</span>
     mapred<span class="o">=</span>mapred<span class="p">)</span>
rhex<span class="p">(</span>z<span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p><strong>Sum of Differences</strong>
The key is the value of <em>A</em> and <em>B</em>, the value is <em>C</em>.</p>
<div class="highlight-r"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre>map <span class="o">&lt;-</span> expression<span class="p">({</span>
  lapply<span class="p">(</span>seq_along<span class="p">(</span>map.values<span class="p">),</span><span class="kr">function</span><span class="p">(</span>r<span class="p">){</span>
    f <span class="o">&lt;-</span> map.values<span class="p">[[</span>r<span class="p">]]</span>
    rhcollect<span class="p">(</span>as.integer<span class="p">(</span>c<span class="p">(</span>map.keys<span class="p">[[</span>r<span class="p">]],</span>f<span class="p">[</span><span class="m">1</span><span class="p">])),</span>f<span class="p">[</span><span class="m">2</span><span class="p">])</span>
<span class="p">})})</span>
</pre></div>
</td></tr></table></div>
<p>Thus each output from a map is a key (assuming there are not any duplicates for <em>B</em> for a given level of <em>A</em>), thus <em>reduce.values</em> has only one observation. All keys sharing the same level of <em>A</em> will be sent to one R process and the tuples <em>as.integer(c(map.keys[[r]],f[1]))</em> will be sorted. <em>reduce.setup</em> is called once when the R process starts processing its assigned partition of keys and <em>reduce.post</em> is called at the end (when all keys have been processed)</p>
<div class="highlight-r"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre></div></td><td class="code"><div class="highlight"><pre>reduce.setup <span class="o">&lt;-</span> expression<span class="p">({</span>
  newp <span class="o">&lt;-</span> <span class="o">-</span>Inf
  diffsum <span class="o">&lt;-</span> <span class="kc">NULL</span>
<span class="p">})</span>
reduce <span class="o">&lt;-</span> expression<span class="p">(</span>
    pre<span class="o">=</span><span class="p">{</span>
      <span class="kr">if</span><span class="p">(</span>reduce.key<span class="p">[[</span><span class="m">1</span><span class="p">]][</span><span class="m">1</span><span class="p">]</span> <span class="o">!=</span> newp<span class="p">)</span> <span class="p">{</span>
        <span class="kr">if</span><span class="p">(</span>newp<span class="o">&gt;-</span>Inf<span class="p">)</span> rhcollect<span class="p">(</span>newp<span class="p">,</span> diffsum<span class="p">)</span> <span class="c1">#prevents -Inf from being collected</span>
        diffsum <span class="o">&lt;-</span> <span class="m">0</span>
        lastval <span class="o">&lt;-</span> <span class="m">0</span>
        newp <span class="o">&lt;-</span> reduce.key<span class="p">[[</span><span class="m">1</span><span class="p">]][</span><span class="m">1</span><span class="p">]</span>
        skip <span class="o">&lt;-</span> <span class="kc">TRUE</span>
      <span class="p">}</span>
    <span class="p">},</span>
    reduce<span class="o">=</span><span class="p">{</span>
      current <span class="o">&lt;-</span> unlist<span class="p">(</span>reduce.values<span class="p">)</span> <span class="c1">#only one value!</span>
      <span class="kr">if</span><span class="p">(</span>!skip<span class="p">)</span> diffsum <span class="o">&lt;-</span> diffsum <span class="o">+</span> <span class="p">(</span>current<span class="o">-</span>lastval<span class="p">)</span> <span class="kr">else</span> skip <span class="o">&lt;-</span> <span class="kc">FALSE</span>
      lastval <span class="o">&lt;-</span> current
    <span class="p">}</span>
  <span class="p">)</span>
reduce.post <span class="o">&lt;-</span> expression<span class="p">({</span>
  <span class="kr">if</span><span class="p">(</span>newp<span class="o">&gt;-</span>Inf<span class="p">)</span> rhcollect<span class="p">(</span>newp<span class="p">,</span>diffsum<span class="p">)</span> <span class="c1">#for the last key</span>
<span class="p">})</span>
</pre></div>
</td></tr></table></div>
<p>To turn on the partitioning and ordering of keys,</p>
<div class="highlight-r"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre>z <span class="o">&lt;-</span> rhmr<span class="p">(</span>map<span class="o">=</span>map<span class="p">,</span>reduce<span class="o">=</span>reduce<span class="p">,</span> inout<span class="o">=</span>c<span class="p">(</span><span class="s">&quot;sequence&quot;</span><span class="p">,</span><span class="s">&quot;sequence&quot;</span><span class="p">),</span>ifolder<span class="o">=</span><span class="s">&quot;/tmp/sort&quot;</span><span class="p">,</span>
  ofolder<span class="o">=</span><span class="s">&quot;/tmp/sort2&quot;</span><span class="p">,</span> part<span class="o">=</span>list<span class="p">(</span>lims<span class="o">=</span><span class="m">1</span><span class="p">,</span>type<span class="o">=</span><span class="s">&#39;integer&#39;</span><span class="p">),</span>
  orderby<span class="o">=</span><span class="s">&quot;integer&quot;</span><span class="p">,</span>cleanup<span class="o">=</span>list<span class="p">(</span>reduce<span class="o">=</span>reduce.post<span class="p">),</span>
  setup<span class="o">=</span>list<span class="p">(</span>reduce<span class="o">=</span>reduce.setup<span class="p">))</span>
rhex<span class="p">(</span>z<span class="p">)</span>
</pre></div>
</td></tr></table></div>
</div>
</div>
<div class="section" id="simple-debugging">
<h2>Simple Debugging<a class="headerlink" href="#simple-debugging" title="Permalink to this headline">¶</a></h2>
<p id="index-14">Consider the example code used to compute the delay quantiles by month (see
<a class="reference internal" href="#delay-quantiles-by-month"><em>Delay Quantiles By Month</em></a> ). We can use <tt class="docutils literal"><span class="pre">tryCatch</span></tt> for some simple
debugging. See the error in line 7, there is no such variable <tt class="docutils literal"><span class="pre">isdelayed</span></tt></p>
<div class="highlight-r"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28</pre></div></td><td class="code"><div class="highlight"><pre>map <span class="o">&lt;-</span> expression<span class="p">({</span>
  tryCatch<span class="p">({</span>
    a <span class="o">&lt;-</span> do.call<span class="p">(</span><span class="s">&quot;rbind&quot;</span><span class="p">,</span>map.values<span class="p">)</span>
    a<span class="p">$</span>delay.sec <span class="o">&lt;-</span> as.vector<span class="p">(</span>a<span class="p">[,</span><span class="s">&#39;arrive&#39;</span><span class="p">])</span><span class="o">-</span>as.vector<span class="p">(</span>a<span class="p">[,</span><span class="s">&#39;sarrive&#39;</span><span class="p">])</span>
    a <span class="o">&lt;-</span> a<span class="p">[</span>!is.na<span class="p">(</span>a<span class="p">$</span>delay.sec<span class="p">),]</span>
    a<span class="p">$</span>isdelayed <span class="o">&lt;-</span> sapply<span class="p">(</span>a<span class="p">$</span>delay.sec<span class="p">,</span><span class="kr">function</span><span class="p">(</span>r<span class="p">)</span> <span class="kr">if</span><span class="p">(</span>r<span class="o">&gt;=</span><span class="m">900</span><span class="p">)</span> <span class="kc">TRUE</span> <span class="kr">else</span> <span class="kc">FALSE</span><span class="p">)</span>
    a <span class="o">&lt;-</span> a<span class="p">[</span>isdelayed<span class="o">==</span><span class="kc">TRUE</span><span class="p">,]</span> <span class="c1">## only look at delays greater than 15 minutes</span>
    apply<span class="p">(</span>a<span class="p">[,</span>c<span class="p">(</span><span class="s">&#39;month&#39;</span><span class="p">,</span><span class="s">&#39;delay.sec&#39;</span><span class="p">)],</span><span class="m">1</span><span class="p">,</span><span class="kr">function</span><span class="p">(</span>r<span class="p">){</span>
      k <span class="o">&lt;-</span> as.vector<span class="p">(</span>unlist<span class="p">(</span>r<span class="p">))</span>
      <span class="kr">if</span><span class="p">(</span>!is.na<span class="p">(</span>k<span class="p">[</span><span class="m">1</span><span class="p">]))</span> rhcollect<span class="p">(</span>k<span class="p">,</span><span class="m">1</span><span class="p">)</span> <span class="c1"># ignore cases where month is missing</span>
    <span class="p">})</span>
  <span class="p">},</span>error<span class="o">=</span><span class="kr">function</span><span class="p">(</span>e<span class="p">){</span>
    e<span class="p">$</span>message <span class="o">&lt;-</span> sprintf<span class="p">(</span><span class="s">&quot;Input File:%s\nAttempt ID:%s\nR INFO:%s&quot;</span><span class="p">,</span>
                 Sys.getenv<span class="p">(</span><span class="s">&quot;mapred.input.file&quot;</span><span class="p">),</span>Sys.getenv<span class="p">(</span><span class="s">&quot;mapred.task.id&quot;</span><span class="p">),</span>e<span class="p">$</span>message<span class="p">)</span>
    stop<span class="p">(</span>e<span class="p">)</span> <span class="c1">## WONT STOP OTHERWISE</span>
  <span class="p">})</span>
<span class="p">})</span>
  reduce <span class="o">&lt;-</span> expression<span class="p">(</span>
    pre<span class="o">=</span><span class="p">{</span>sums <span class="o">&lt;-</span> <span class="m">0</span><span class="p">}</span> <span class="p">,</span>
    reduce <span class="o">=</span> <span class="p">{</span>sums <span class="o">&lt;-</span> sums<span class="o">+</span>sum<span class="p">(</span>unlist<span class="p">(</span>reduce.values<span class="p">))},</span>
    post <span class="o">=</span> <span class="p">{</span> rhcollect<span class="p">(</span>reduce.key<span class="p">,</span> sums<span class="p">)</span> <span class="p">}</span>
    <span class="p">)</span>
mapred <span class="o">&lt;-</span> list<span class="p">()</span>
mapred<span class="p">$</span>rhipe_map_buff_size <span class="o">&lt;-</span> <span class="m">5</span>
z <span class="o">&lt;-</span> rhmr<span class="p">(</span>map<span class="o">=</span>map<span class="p">,</span>reduce<span class="o">=</span>reduce<span class="p">,</span>combiner<span class="o">=</span><span class="kc">TRUE</span><span class="p">,</span>inout<span class="o">=</span>c<span class="p">(</span><span class="s">&quot;sequence&quot;</span><span class="p">,</span><span class="s">&quot;sequence&quot;</span><span class="p">)</span>
          <span class="p">,</span>ifolder<span class="o">=</span><span class="s">&quot;/airline/blocks/&quot;</span><span class="p">,</span>ofolder<span class="o">=</span><span class="s">&quot;/airline/quantiledelay&quot;</span>
          <span class="p">,</span>mapred<span class="o">=</span>mapred<span class="p">)</span>
z<span class="o">=</span>rhex<span class="p">(</span>z<span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>Produces a slew of errors like (output slightly modified to fit page)</p>
<div class="highlight-r" id="index-15"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span class="m">10</span><span class="o">/</span><span class="m">08</span><span class="o">/</span><span class="m">04</span> <span class="m">00</span>:<span class="m">41</span>:<span class="m">20</span> INFO mapred.JobClient: Task Id :
  attempt_201007281701_0273_m_000023_0<span class="p">,</span> Status : FAILED
java.io.IOException: MROutput<span class="o">/</span>MRErrThread failed:java.lang.RuntimeException:
R ERROR
<span class="o">=======</span>
Error in <span class="sb">`[.data.frame`</span><span class="p">(</span>a<span class="p">,</span> isdelayed <span class="o">==</span> <span class="kc">TRUE</span><span class="p">,</span> <span class="p">)</span> : Input File:
Attempt ID:attempt_201007281701_0273_m_000023_0
R INFO:object <span class="s">&quot;isdelayed&quot;</span> not found
</pre></div>
</td></tr></table></div>
<p>It can be very useful to provide such debugging messages since R itself doesn&#8217;t
provide much help. Use this to provide context about variables, such printing
the first few rows of relevant data frames (if required). Moreover, some errors
don&#8217;t come to the screen instead the job finishes successfully (but very quickly
since the R code is failing) but the error message is returned as a counter. The
splits succeed since Hadoop has finished sending its data to R and not listening
to for errors from the R code. Hence any errors sent from R do not trigger a
failure condition in Hadoop. This is a RHIPE design flaw. To compensate for
this, the errors are stored in the counter <em>R_ERROR</em>.</p>
<p>Unfortunately, RHIPE does not offer much in the way of debugging. To run jobs
locally that is, Hadoop will execute the job in a single thread on one computer,
set <tt class="docutils literal"><span class="pre">mapred.job.tracker</span></tt> to <em>local</em> in the <tt class="docutils literal"><span class="pre">mapred</span></tt> argument of <tt class="docutils literal"><span class="pre">rhmr</span></tt>. In
this case, <tt class="docutils literal"><span class="pre">shared.files</span></tt> cannot be used and <tt class="docutils literal"><span class="pre">copyFiles</span></tt> will not work.</p>
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="f1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[1]</a></td><td>This can be changed by the user, see <em class="xref std std-ref">Options For RHIPE</em>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="f2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[2]</a></td><td>A similar ordering exists for character vectors (<tt class="docutils literal"><span class="pre">NA</span></tt> not.. allowed). Specify by setting <tt class="docutils literal"><span class="pre">orderby=&quot;character&quot;</span></tt> in the call to <tt class="docutils literal"><span class="pre">rhmr</span></tt></td></tr>
</tbody>
</table>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="introduction.html">Introduction</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="texttransfirm.html">Transforming Text Data</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2010, Saptarshi Guha.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
  </body>
</html>